---
title: "BRCA_Deep_Dive_Processing"
author: "KEC"
date: "2024-04-04"
output: html_document
editor_options: 
  chunk_output_type: console
---

## CCVA Data Processing

This R markdown prepares data inputs for a Climate Change Vulnerability 
Assessment (CCVA) for water supplies at BRCA

### 1. Setup Workspace

First, install and/or load required packages and functions.

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

source('setup.R')
library("readxl")
library("trend")

```


Define park using 4-digit NPS Unit Code. 
Codes for all parks can be found at: 
<https://www.nps.gov/aboutus/foia/upload/NPS-Unit-List.xlsx>.

Download the park boundary from the NPS IRMA DataStore as an sf object.

```{r park_dat, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

park <- "BRCA"

# Get park geometry and metadata
park_boundary <- getParkBoundary(park = park)
state <- park_boundary$STATE
park_name <- park_boundary$UNIT_NAME
park_name_short <- gsub(" National Park", "", park_name)

# Define a color pallette to use throughout - note can change for regions? feels?
pal = c("#DFCB34","#0067A2", "#CB7223", "#289A84", "#7FA4C2", "#AF7E56","#8C2B0E", "#FEB359", "#132F5B", "#435F90", "#68434E", "#B47E83", "#444E7E", "red","hotpink", "#B7ABBC")#FD8700", "#D8511D")

# Define report name
report_name <- 
  paste0("Climate Change Vulnerability Assessment for Water Supplies at ",
         park_name)

```

Data import option

Read in data if you've already downloaded it
```{r read_data}

# Commented out for now because this is old data.

## path to data folder (from project directory)
#path <- "data/park/"

# read in data
#try(
#load(paste0(path, "/", park, "/", park, "_report_data_v2.RData")))
## terra object issue when saving as .RData, so saved as separate .tif
```


### 2. Water Supply Database

A water supply system database was created for this project using various NPS
and public databases.  The database contains a "supply" table and a "source"
table.  The "supply" table includes a row for each water supply system at
the park. The source table contains a row for each source of water (e.g.,
individual wells, diversions, and springs) associated with each supply. The
two tables are related by a shared column -> wsd_system_id.

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}


table_path <- "data/Water_Supply_Systems/NPS_Water_Systems_Database_Aug8.xlsx"

# Supply table (Currently filtered to Utah)
supply_table <- read_excel(table_path, sheet = 2, na = "NA") %>%
  janitor::clean_names() %>%
  dplyr::filter(park_name == park_boundary$UNIT_NAME,
                in_use == "Active")
  
# Source table
source_table <- read_excel(table_path, sheet = 4, na = "NA") %>%
  janitor::clean_names() %>%
  #dplyr::filter(state == "UT")
  dplyr::filter(wsd_system_id %in% supply_table$wsd_system_id) %>%
  dplyr::mutate(well_depth = as.numeric(well_depth))

# Copy of source table as sf_object - some columns without location data are
# dropped. Circle back to this later.
source_table_locs <- source_table %>%
  drop_na(c("source_longitude", "source_longitude")) %>%
  st_as_sf(., 
           coords = (c("source_longitude","source_latitude")), 
           crs = 4326,
           remove = FALSE) 

# Optional preview water source locations
mapviewOptions(fgb = FALSE, 
               georaster = FALSE, 
               basemaps = c("Esri.WorldTopoMap", 
                            "Esri.WorldImagery"))
mapview(source_table_locs,
        zcol = "water_system_name",
        layer.name = "Source:",
        col.regions = pal) + 
  mapview(park_boundary,
          col.regions = "forestgreen",
          alpha.regions = 0.2,
          legend = FALSE)

```


### 3. Delineate Source Watershed and/or Aquifer

```{r source_water}

# Get source
get_aoi_source <- function(df) {
#' @param df sf dataframe containing point geometry AND
#'           source_type column. Valid source types include:
#'           "Shallow Groundwater"
#'           "River/Stream"
#'           "Karst Aquifer and Spring"
#'           "Spring"
#'           "Deep Groundwater"
#'           Note, this will most likely be source_table_locs
  
  # for testing
   # df <- source_table_locs
  
  df_crs <- st_crs(df)
  
  get_method_type <- function(df) {
  
  df_update <- df %>%
    dplyr::mutate(
      method = 
        ifelse(source_type %in% c("Shallow Groundwater", "River/Stream"),
               "SHALLOW METHOD",  
#               ifelse(source_type %in% c("Karst Aquifer and Spring", "Spring"), 
 #                     "SPRING METHOD", 
                           ifelse(source_type %in% c("Deep Groundwater", 
                                                     "Spring", 
                                                     "Karst Aquifer and Spring"), 
                                  "DEEP METHOD", 
                                  "OTHER")))
  
    }

  df <- get_method_type(df = df)

  # Initiate empty aoi vector
  aoi <- vector("list", nrow(df))  
  
  # Populate each row with aoi
  for(i in 1:nrow(df)) {
    
   #i <- 2
    
    # Shallow method - get watershed
    if (df[i,"method"][["method"]] == "SHALLOW METHOD") {
      
      # First get watershed
      ws <- df[i,] %>% 
        getXYWatersheds(sf = ., coordinates = NULL) %>%
        dplyr::summarize() %>%
        st_transform(., crs = df_crs) %>%
        dplyr::mutate(type = "Watershed",
                      name = "Watershed") 
      aoi[[i]] <- ws

    if (df[i,"type"][["type"]] == "Well") {
      
      # Then get potential aquifer (min age geologic unit)
      all_formations <- df[i,] %>%
        get_rockd(points = .) %>%
        dplyr::filter(b_int_age == min(b_int_age)) %>%
        st_make_valid() %>%
        dplyr::mutate(type = "Formation")
      
      if (nrow(all_formations) > 1) {
        
        combined_unit <- st_union(all_formations)

        combined_unit <- st_sf(geometry = combined_unit, 
                      all_formations[1, 
                                      !names(all_formations) %in% "geometry"])
        all_formations <- combined_unit
      }
      
      aoi[[i]] <- bind_rows(ws, all_formations)
    }
      
      
      
      # Deep GW method - get intersecting geologic units
    } else if (df[i,"method"][["method"]] == "DEEP METHOD") {
      
      # extract some info about the formation
      form_type <- word(df[i,]$aquifer_name,-1)
      form_name_long <- df[i,]$aquifer_name
      form_name_short <- word(form_name_long, 1)
      
      # get all formations intersecting with point
      all_formations <- df[i,] %>%
        get_rockd(points = .)
      
      # Now, check if metadata available by searching macrostrat using the
      # formation name.  filter all_formations to match metadata
      # found using formation name
      
      # Clear "form_info" variable from previous loop just incase
      if (exists("form_info")) {rm("form_info")}
      
      # Search macrostat database for formation name
      if (!is.na(form_name_short)) {
        form_info <- get_formation_info(gsub(" ","_",form_name_short), form_type) #%>%
          #dplyr::filter(grepl(form_name,Fm)) 
      }
      
      if (exists("form_info")) {
        # Extract age from that info
        form_min_age <- form_info$t_age %>% min(., na.rm = TRUE)
        form_max_age <- form_info$t_age %>% max(., na.rm = TRUE)
      
        # Use formation name to filter all_formations
        select_formation <- all_formations %>%
          dplyr::filter(grepl(form_name_long, name))
        
        # If nothing returned, use formation age to filter all_formations
        if(nrow(select_formation) < 1) {
          start_buffer = 5
          while(nrow(select_formation) <1) {
            select_formation <- all_formations %>%
                    dplyr::filter(t_age >= form_min_age-start_buffer & 
                                    t_age <= form_max_age+start_buffer)
            start_buffer <- start_buffer + 5
            if (start_buffer > 50) break # break if nothing matched with +/- 50 years
          }
        } 
        
        # If still nothing returned, return all_formations (for now)
        # Will need to investigate further. 
        if (nrow(select_formation) < 1) {
          select_formation <- all_formations
        }
      } else {
        # if no metadata available, then assign select_formation as all formations
        select_formation <- all_formations
      }
      
      select_formation <- select_formation %>%
        st_transform(., df_crs) %>%
        dplyr::mutate(type = "Formation")
      
        aoi[[i]] <- select_formation
      }
    }

  
  df$aoi <- purrr::map(aoi, bind_rows)
  #df['aoi'] <- aoi

  return(df)
  
  }


source_table_locs <- get_aoi_source(source_table_locs)

watersupply_watershed <- source_table_locs$aoi %>%
  bind_rows() %>%
  dplyr::filter(type == "Watershed") %>%
  distinct() %>%
  st_transform(., crs = st_crs(park_boundary))

mapview(source_table_locs,
        zcol = "water_system_name",
        layer.name = "Source:",
        col.regions = c("tomato","dodgerblue"),
        cex = 4,
        homebutton = FALSE) + 
  mapview(park_boundary,
          col.regions = "forestgreen",
          alpha.regions = 0.2,
          homebutton = FALSE,
          legend = FALSE) +
  mapview(source_table_locs$aoi %>% bind_rows(),
          zcol = "type",
          layer.name = "AOIs",
          col.regions = pal,
          homebutton = FALSE,
          alpha.regions = 0.2)

```


Various climate, hydrology, and geography data are required to generate a CCVA 
for the selected National Park. The following code chunks download and describe 
this data.


### 4. Park PODs

Park water supplies may be sourced from within or beyond the park boundary. This
chunk pulls in state-reported water supply locations, or points of diversion (PODS)
that occur within a buffer distance of the park boundary. Then, PODs are filtered
to identify specific PODs associated with park water supplies. For some parks, 
the water supply system ID is linked using the water supply database. For 
others, we assume the water supply is any POD owned by NPS within the select buffer.

\*\*\*\*KEC: This assumes POD_state has "OWNER" column and that NPS is 
identified by string "NATIONAL PARK". Should probably update match strings in 
future as other POD databases are brought in.

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

# Now, get state specific points of diversion (POD) (i.e., water supply points)
# EDIT NOTE - Eventually nest into a getPODall function with aoi and dist
# args which then applies the state-specific function.

# Set distance and AOI for POD search
buffer_dist <- .05 # in decimal degrees lat/long

aoi <- 
  park_boundary 

# Dictionary to map POD functions to states
POD_dict <- c(
  "CA" = getPODCalifornia,
  "CO" = getPODColorado,
  "MT" = getWaterRightsMontana,
  "NV" = getPODNevada,
  "UT" = getPODUtah
)

# Assign POD_state using the condition map
if (state %in% names(POD_dict)) {
  
  POD_state <- POD_dict[[state]](aoi, buffer_dist)  # Pass additional arguments

  } else {
    
  print("No PODs returned.")

  }


# Filter using water supply database to identify PODs associated park water 
# supplies. If table does not have adequate information, select by POD
# owner and location metadata

if(supply_table %>% drop_na(water_rights_id) %>% nrow() > 0) {
  
  POD_supply <- POD_state %>%
    #dplyr::filter(WRNUM %in% c("61-893", "2061001M00")) %>%
    dplyr::filter(WRNUM %in% supply_table$water_rights_id) %>%
    dplyr::distinct(LOCATION, .keep_all = TRUE) %>%
    dplyr::mutate(
      name = supply_table %>% 
        pull (water_system_name)) 
  
} else {
    
  POD_supply <- POD_state %>%
    dplyr::filter(
      OWNER %like% "NATIONAL PARK",
      str_detect(SUMMARY_ST, "A|P")) %>% # approved / perfected applications
      #str_detect(USES,"D|M|O|I")) %>%  # filter by POD use category
    dplyr::distinct(WRNUM,
                    .keep_all = TRUE) %>%
    mutate(name = source)
      
      #if (nrow(Suppliers) >= 1) {
      #  POD_supply <- POD_supply %>%
      #    left_join(., Suppliers, by = WRID)
      #}
}

# All PODS within park
POD_all <- 
  POD_state %>% 
  dplyr::filter(park_right == "Park") %>% 
  dplyr::distinct(WRNUM, .keep_all = TRUE)


mapview(POD_state,
        #zcol = "CFS",
         layer.name = "State Reported PODs",
         col.regions = pal[4:6],
        homebutton = FALSE,
        cex = 3) +
mapview(source_table_locs,
        zcol = "water_system_name",
        layer.name = "Source:",
        homebutton = FALSE,
        col.regions = c("tomato","dodgerblue"),
        cex = 4) + 
  mapview(park_boundary,
          col.regions = "forestgreen",
          alpha.regions = 0.2,
          homebutton = FALSE,
          legend = FALSE) +
  mapview(source_table_locs$aoi %>% bind_rows(),
          zcol = "type",
          layer.name = "AOIs",
          col.regions = pal,
          homebutton = FALSE,
          alpha.regions = 0.2)
  


```

### 5. Nearest NWIS Sites

For many parks, the nearest USGS stream gage is far away. Therefore, here we
pull in all NWIS gages within 100 km of the park boundary. Of those, we only 
select stream gages that are considered "reference" gages in the 
[GAGES-II database (Falcone, 2011)](https://pubs.usgs.gov/publication/70046617).
We then select the gage that is closest to the park with the most complete
period of record and delineate associated watershed using the `get_nldi_basin()` 
function from the {nhdplusTools} package.

```{r, eval = TRUE, message = FALSE, warning = FALSE}

# Get all NWIS sites
nwis <- listNWIS(aoi = watersupply_watershed %>% 
                   dplyr::summarize(), dist = .3) 

# Get NWIS Stream Gages
ref_gages <- get_gagesII(id = nwis$site_no) %>%
             dplyr::filter(class == "Ref")

nwis_nearest_stream_gage <- nwis %>%
  dplyr::filter(site_no %in% ref_gages$staid,
                data_type_cd == "dv") %>%
  dplyr::left_join(st_drop_geometry(ref_gages), 
                   by = c("site_no" ="staid")) %>%
  dplyr::mutate(distance = sf::st_distance(geometry, 
                                           watersupply_watershed)) %>%
  dplyr::slice_max(., distance) # grab nearest only


# Get watersheds associated with nearest stream gage
nwis_nearest_watershed <- 
  nwis_nearest_stream_gage$site_no %>%
  purrr::map_dfr(~nldi_finder(site_no = .)) %>%
  dplyr::mutate(data = map(site_no, ~nldi_meta(site_no = .))) %>%
  unnest(cols = c(data)) %>%
  dplyr::left_join(st_drop_geometry(nwis_nearest_stream_gage), by = "site_no")


# Download data from reference stream sites
nwis_nearest_discharge <- 
  dataRetrieval::readNWISdv(siteNumbers = nwis_nearest_stream_gage$site_no,
                            parameterCd = c('00060','00065')) %>%
    dplyr::rename(c("discharge" = "X_00060_00003",
                    "date" = "Date")) %>%
    dplyr::filter(year(date) >= 1980) %>%
    dplyr::group_by(site_no) %>%
    dplyr::mutate(dev_mean = discharge - mean(discharge, na.rm = TRUE)) %>% 
    dplyr::select(date, site_no, discharge, dev_mean) %>%
  dplyr::mutate(
    discharge_in_nwis = 86400 * 12 * discharge /
      (nwis_nearest_watershed$drain_sqkm * 1.076e+7))

#nldi_flowlines <- 
#  dplyr::summarize(nldi_watershed) %>%
#  mapNHDPlusHR() %>% 
#  dplyr::summarize()

# Now Get Gw sites
#62611 (Groundwater level above NAVD 1988, feet)
#72019 (Depth to water level, feet below land surface)
nwis_groundwater <- nwis %>%
  dplyr::filter(begin_date != end_date,
                year(end_date) > 1985,
                n_obs > 50,
                code == 62611) %>%
  dplyr::mutate(dist = st_distance(geometry,park_boundary) %>%
                as.numeric()) %>%
  #dplyr::filter(dist <= 1600*3) %>%
  add_gw_meta()


# pull those sites groundwater level data and convert to monthly mean
  nwis_groundwater_levels <- 
    dataRetrieval::readNWISgwl(nwis_groundwater$site_no) %>%
    dplyr::filter(parameter_cd == 62611,
                  year(as.Date(lev_dt)) >= 1980) %>% # 72019 =Depths, 62611=elevation
    dplyr::mutate(ym = lubridate::ym(substr(lev_dt, 1, 7))) %>% 
    dplyr::group_by(ym, site_no) %>%
    dplyr::summarize(mean_lev_va = mean(sl_lev_va, na.rm. = TRUE), # elevation
                     #mean_lev_va = mean(lev_va, na.rm. = TRUE), # depths
                     .groups = "keep") %>%
    dplyr::select(ym, site_no, mean_lev_va) %>%
    dplyr::group_by(site_no) %>%
    dplyr::mutate(dev_mean = mean_lev_va - mean(mean_lev_va, na.rm = TRUE))
    #tidyr::pivot_wider(names_from = site_no, names_prefix = "well_", 
                       #values_from = mean_lev_va) #%>%

ggarrange(  
  ggplot(nwis_nearest_discharge, 
         aes(x = date, y = discharge, color = site_no)) +
    geom_line() +
    xlim(as.Date("1980-01-01"), as.Date("2025-01-01")) +
    scale_color_manual("NWIS Site #", values = pal[2:6]) +
    theme_bw() +
    labs(x = "", y = "Discharge (cfs)"),
  ggplot(nwis_groundwater_levels, 
       aes(x = ym, y = dev_mean, color = site_no)) + 
    geom_line() + 
    scale_color_manual("NWIS Site #", values = pal) + 
    theme_bw() +
    labs(x = "", y = "GW Lev (ft) deviation from mean"),
  ncol = 1,
  align = "hv"
)

  ggplot(nwis_groundwater_levels, 
       aes(x = ym, y = dev_mean, color = site_no)) + 
    geom_line() + 
    scale_color_manual("NWIS Site #", values = pal) + 
    theme_bw() +
    #labs(x = "", y = "GW Lev (ft) deviation from mean") %>% 
    facet_wrap(~site_no)


  # Optional preview water source locations
mapviewOptions(fgb = FALSE, 
               georaster = FALSE, 
               basemaps = c("Esri.WorldTopoMap"))#,
#                            "Esri.WorldImagery"))
mapview(nwis_groundwater, 
        #zcol = "site_no", 
        col.regions = "yellow",
        cex = 4,
        homebutton = FALSE,
       layer.name = "NWIS GW Sites") +
mapview(nwis_nearest_stream_gage,
        zcol = "site_no",
        layer.name = "NWIS SW Sites",
        col.regions = "hotpink",
        homebutton = FALSE,
        cex = 4) +
  mapview(nwis_nearest_watershed,
          legend = FALSE,
          homebutton = FALSE,
          col.regions = "hotpink",
          alpha.regions = 0.3) +
mapview(source_table_locs,
        zcol = "water_system_name",
        layer.name = "Source:",
        homebutton = FALSE,
        col.regions = c("tomato","dodgerblue"),
        cex = 4) + 
  mapview(park_boundary,
          col.regions = "forestgreen",
          alpha.regions = 0.2,
          homebutton = FALSE,
          legend = FALSE) +
  mapview(source_table_locs$aoi %>% bind_rows(),
          zcol = "type",
          layer.name = "AOIs",
          col.regions = pal,
          homebutton = FALSE,
          alpha.regions = 0.2)
  


```

### 6. Park supplied well data

Here, we pull in the daily well level data for both supply wells associated
with the East Creek Water system.  This data was digitized from manual field
notes that were made by park staff.

```{r well_dat, eval = TRUE, message = FALSE, warning = FALSE}

well_data <- read_csv('data/park/BRCA/manual/BRCA_Well_Data.csv', na = c("NaN", "NA", "")) %>%
  clean_names() %>%
  dplyr::mutate(static_in = ifelse(static_in == "-", NA,
                              ifelse(static_in == "NaN", NA, 
                                as.numeric(static_in))),
                date = mdy(date),
                static_ft = -static_in/12) %>%
  # Remove some outliers / bad data (next-day level change > 1.5 ft)
   mutate(diff = abs(static_ft - lag(static_ft, default = NA)),
         static_ft = ifelse(diff > 1.5, NA, static_ft)) %>%
  dplyr::select(date,static_ft,well) %>%
  complete(date = seq.Date(min(date),max(date), by = "day")) %>% 
  arrange(date) %>%
  dplyr::mutate(static_ft_c = static_ft) %>%
  group_by(well) %>%
  mutate(static_ft_c = na.approx(static_ft, na.rm = FALSE)) 
 
  
# Plot Well data
ggplot(well_data) +
  geom_point(aes(x = date, y = static_ft, color = well)) + 
  geom_line(aes(x = date, y = static_ft_c, color = well), linetype = "dashed") +
  theme_bw() +
  labs(y = "Groundwater Depth (ft)", x = "") +
  scale_color_manual("", values = c("dodgerblue","tomato"))


```


### 7. Selected Climate Futures

Climate futures were previously compiled for park and Koppen centroids. This
data was used to select which of the CMIP5 climate models to use to represent
"hot dry" and "warm wet" scenarios. 

Source for Koppen-Geiger climate classification maps:

Beck, H. E., Zimmermann, N. E., McVicar, T. R., Vergopolan, N., Berg, A., & 
Wood, E. F. (2018). Present and future Köppen-Geiger climate classification maps
at 1-km resolution. Scientific data, 5(1), 1-12.

<https://figshare.com/articles/dataset/Present_and_future_K_ppen-Geiger_climate_classification_maps_at_1-km_resolution/6396959/2>


```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}


select_cfs <- data.table::fread('data/parkwide_gcms_wbm_filtered.csv') %>%
  dplyr::filter(park %in% {{park}},
                  CF %in% c("Warm Wet", "Hot Dry")) %>%
  distinct(GCM, .keep_all = TRUE)

# If there is more than one model selection for a CF scenario, grab the more
# divergent.
if (nrow(select_cfs) > 2) {
  if (nrow(select_cfs %>% dplyr::filter(CF == "Hot Dry")) > 1) {
        select_cfs <- select_cfs %>%
                group_by(CF) %>%
                slice_min(delta_pr)
  }
  if ((nrow(select_cfs %>% dplyr::filter(CF == "Warm Wet")) > 1) ) {
          select_cfs <- select_cfs %>%
            group_by(CF) %>%
            slice_max(delta_pr)
  }
}
  

```


### 8. Climate data 

Import climate data for park centroid.

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}


get_climate_historic <- function(sf, idx_col, start_date, end_date) {
#' @param df An SF dataframe containing AOI
#' @param 
  
  clim <- vector("list", length = nrow(sf))
  
for (i in 1:nrow(sf)) {

  aoi <- sf[i,]
  name <- aoi[[sym(idx_col)]]
  
  print('Downloading GridMET...')
  
  clim[[i]] <- climateR::getGridMET(AOI = aoi, 
                      varname = c("tmmx", "tmmn", "pr", "pet"),#"vs"),
                      startDate = start_date,
                      endDate = end_date) 
  
  clim_crs <- st_crs(clim[[i]][[1]])
  
  # getGridMET defaults AOI to bbox - so crop / mask results to sf extent
  clim[[i]] <- clim[[i]] %>%
      purrr::map(
        ~terra::crop(., st_transform(aoi, crs = clim_crs), mask = TRUE), 
        crs = clim_crs) 
  
  print('GridMET download complete!')
  
  clim[[i]] <- clim[[i]] %>%
    purrr::map_dfr(~ as.data.frame(., xy = TRUE)) %>%
    data.table() %>%
    pivot_longer(-(x:y),
                 names_to = "var_temp",
                 values_to = "val") %>%
    separate_wider_delim(var_temp, "_", names = c("var","date")) %>%
    drop_na(val) %>%
    group_by(x,y,date) %>% 
  pivot_wider(names_from = "var", values_from = "val") %>%
  dplyr::mutate(date = as.Date(date)) %>%
     mutate(ppt_mm = pr,
         tmax_C = tmmx - 273.15,
         tmin_C = tmmn - 273.15,
         tmean_C = (tmax_C + tmin_C)/2,
         site = name) 
  
} 
  
  clim2 <- bind_rows(clim) %>%
    dplyr::select(x,y,date,ppt_mm,tmax_C,tmin_C,tmean_C,site) %>%
    dplyr::mutate(GCM = "GridMET", 
                  RCP = NA)
  
  return(clim2)
}

get_climate_future <- function(sf, 
                               idx_col, 
                               start_date, 
                               end_date,
                               GCM = select_cfs$GCM) {
#' @param sf An SF dataframe containing AOI
#' @param name
#' @param start_date
#' @param end_date
#' @param GCM
  
  #sf <- watersupply_watershed
  #name <- "WS"
  #start_date <- "2024-01-01"
  #end_date <- "2028-01-01"
  #GCM <- select_cfs$GCM
  #col_name <- "name"
  #i <- 1
  #j <- 1
  
    clim <- vector("list", length = length(GCM) * nrow(sf))
    idx <- 0
    
for (i in 1:nrow(sf)) {

  aoi <- sf[i,]
  name <- aoi[[sym(idx_col)]][i]
  
  # Get models to run
  models <- str_extract(GCM, "^[^.]+")

  # Get scenarios (rcps) to run
  scenarios <- str_extract(GCM, "(?<=\\.).*")
  
  for (j in 1:length(GCM)) {
    
    idx <- idx + 1
    
    print('Downloading MACA...')
    
    clim[[idx]] <- climateR::getMACA(AOI = aoi, 
                      varname = c("tasmax", "tasmin", "pr"),#,"pet","vs"),
                      model = models[j],
                      scenario = scenarios[j],
                      startDate = start_date,
                      endDate = end_date) 

  
  
    clim_crs <- st_crs(clim[[idx]][[1]])
  
  # getGridMET defaults AOI to bbox - so crop / mask results to sf extent
    clim[[idx]] <- clim[[idx]] %>%
        purrr::map(
          ~terra::crop(., st_transform(aoi, crs = clim_crs), mask = TRUE), 
          crs = clim_crs) 
  
    clim[[idx]] <- clim[[idx]] %>%
      purrr::map_dfr(~ as.data.frame(., xy = TRUE)) %>%
      data.table() %>%
      pivot_longer(-(x:y),
                   names_to = "var_temp",
                   values_to = "val") %>%
      separate_wider_delim(var_temp, "_", names = c("var","date","GCM","Ensemble","RCP")) %>%
      drop_na(val) %>%
      group_by(x,y,date) %>% 
    pivot_wider(names_from = "var", values_from = "val") %>%
    dplyr::mutate(date = as.Date(date)) %>%
       mutate(ppt_mm = pr,
           tmax_C = tasmax - 273.15,
           tmin_C = tasmin - 273.15,
           tmean_C = (tmax_C + tmin_C)/2,
           site = name) %>%
      dplyr::select(c(x,y,date,GCM,RCP,ppt_mm,tmax_C, tmin_C, tmean_C, site))
  }
}  
 clim2 <- bind_rows(clim)
  
      print('MACA download complete!')
      
  return(clim2)
}


# Get historic Climate Data for Water Supply Source AOI
clim_source_hist <- get_climate_historic(sf = watersupply_watershed,
                           idx_col = "name",
                           start_date = "1979-01-01",
                           end_date = "2023-01-01") 

# Get future climate data for water supply AOI
clim_source_fut <- get_climate_future(sf = watersupply_watershed,
                                      idx_col = "name",
                                      start_date = "2024-01-01",
                                      end_date = "2075-01-01",
                                      GCM = select_cfs$GCM)

clim_source <- bind_rows(clim_source_hist, clim_source_fut)

# Get historic Climate Data for nearest Stream Gage AOI
clim_nwis <- get_climate_historic(sf = nwis_nearest_watershed,
                         idx_col = "site_no",
                         start_date = nwis_nearest_discharge$date %>% min(),
                         end_date = "2023-01-01")
# Join wbm results with discharge
clim_nwis2 <- clim_nwis %>%
  left_join(., nwis_nearest_discharge , by = c("date", "site"="site_no"))


source_fut_pts <- clim_source_fut %>% 
  ungroup() %>% 
  distinct(x,y, .keep_all = TRUE) %>% 
  st_as_sf(., coords = c("x","y"), crs = st_crs(4326), remove = FALSE) %>%
  dplyr::select(c(date,GCM,RCP,site,x,y))

source_hist_pts <- clim_source_hist %>% 
  ungroup() %>% 
  distinct(x,y, .keep_all = TRUE) %>% 
  st_as_sf(., coords = c("x","y"), crs = st_crs(4326), remove = FALSE) %>%
  dplyr::select(c(date,GCM,RCP,site,x,y))

nwis_pts <- clim_nwis %>% 
  ungroup() %>% 
  distinct(x,y, .keep_all = TRUE) %>% 
  st_as_sf(., coords = c("x","y"), crs = st_crs(4326), remove = FALSE) %>%
  dplyr::select(c(date,GCM,RCP,site,x,y))

mapview(source_fut_pts, 
        col.regions = "black",
        layer.name = "MACA") + 
  mapview(watersupply_watershed, 
          col.regions = "dodgerblue", 
          alpha.regions = 0.2,
          layer.name = "Source Watershed") + 
  mapview(source_hist_pts, 
          col.regions = "red",
          layer.name = "GridMET") +
mapview(source_hist_pts %>% 
          st_transform(., 32612) %>% 
          st_buffer(, dist = 2000),
        col.regions = "red",
        alpha.regions = 0.2,
        legend = FALSE) +
  mapview(nwis_pts,
          col.regions = "red",
          legend = FALSE) +
  mapview(nwis_nearest_watershed,
          col.regions = "seagreen",
          alpha.regions = 0.3,
          layer.name = "NWIS Watershed")

```



### 9. WBM 

Run the NPS water balance model for each gridmet point in the AOI

```{r run_wbm, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

source("KEC_Scratch/WB_Functions.R")

# Load DEM and Soil Rasters
  
# DEM (from NPS WBM group) -> in meters
dem <- terra::rast(here::here('data/all/elevation_cropped.tif')) %>%
  terra::project(crs(nwis_pts))

# Soil storage properties raster (from NPS WBM group)
soil <- terra::rast(here::here('data/all/water_storage.tif')) %>%
  terra::project(crs(nwis_pts)) # cm to mm

SWC_vals = terra::extract(soil, nwis_pts)$water_storage

ggplot() + 
  geom_histogram(aes(x = SWC_vals)) +
  theme_bw() +
  labs(y = "Count", x = "Maximum Soil Water Content (mm)") #+ 

# Calculate slope & aspect
# For slope, 4 better for "smooth" surfaces, 8 better for rough See:
# https://www.rdocumentation.org/packages/raster/versions/3.1-5/topics/terrain
slope <- terra::terrain(dem, v = "slope", 
                        unit = "degrees", 
                        neighbors = 8) 

aspect <- terra::terrain(dem, 
                         v = "aspect", 
                         unit = "degrees")

# Hock, 2003 (https://doi.org/10.1016/S0022-1694(03)00257-9)
# Melt factor for Goosebury Creek in Utah is 2.5

run_NPS_wbm <- function(points, 
                        climate_data, 
                        PET_Method = c("Oudin"), 
                        hock_coef = 4, 
                        PET_mult = 1,
                        SOIL_mult = 1,
                        Snowpack.Init = 0,   # according to Mike's code
                        Soil.Init = 0, # Init full from Mike's code, empty in Ambers
                        Shade.Coeff = 1,
                        T.Base = 0) {

  # Code for testing:
  #points <- source_fut_pts
  #climate_data <- clim_source_fut
  
  #PET_Method <- "Oudin" 
  #hock_coef <-  4 
  #Snowpack.Init <- 0   # according to Mike's code
  #Soil.Init <- 0 # Init full from Mike's code, empty in Ambers
  #Shade.Coeff <- 1
  #T.Base <- 0

  
#' Run NPS water balance model for a given set of points and associated climate
#' data.   

# Extract params for points
print("Extracting params at points...")
  points2 <- 
    points %>%
    data.table() %>%
    dplyr::mutate(pt_num = row_number(),
                  Elev = terra::extract(dem, points)$elevation_cropped,
                  Aspect = terra::extract(aspect, points)$aspect,
                  Slope = terra::extract(slope, points)$slope,
                  SWC.Max = SOIL_mult * terra::extract(soil, points)$water_storage,
                  Snowpack.Init = Snowpack.Init,   # according to Mike's code
                  Soil.Init = Soil.Init, # Init full from Mike's code, empty in Ambers
                  Shade.Coeff = Shade.Coeff)

  climate_data <- climate_data %>%
    data.table() %>%
    left_join(., points2 %>% dplyr::select(x,y,pt_num) %>% st_drop_geometry(), by = c("x","y"))
    
  GCMs <- climate_data[["GCM"]] %>% unique()
  
# Now, run WBM for each point & GCM
  DailyWB_ret <- vector(mode = "list", 
                        length = nrow(points2)*length(GCMs))
  ct <- 0
  
print("Running wbm...")
for (j in 1:length(GCMs)) {

  for (i in 1:nrow(points2)) {
    ct <- ct + 1
    #print("Running WBM for grid cell:")
    #print(i)
    #i <- 1
    point <- points2[i,]  
    DailyWB <- climate_data %>% 
      dplyr::filter(pt_num == point$pt_num,
                    GCM == GCMs[j]) %>%
      data.table()
    
    DailyWB$doy <- yday(DailyWB$date)
    DailyWB$daylength <- get_daylength(DailyWB$date, point$y)
    DailyWB$jtemp = as.numeric(get_jtemp(point$y, point$x))
    DailyWB$F = get_freeze(DailyWB$jtemp, DailyWB$tmean_C)
    DailyWB$RAIN = get_rain(DailyWB$ppt_mm, DailyWB$F)
    DailyWB$SNOW = get_snow(DailyWB$ppt_mm, DailyWB$F)
    DailyWB$MELT = get_melt(DailyWB$tmean_C, DailyWB$jtemp, hock=hock_coef, DailyWB$SNOW, point$Snowpack.Init)
    DailyWB$PACK = get_snowpack(DailyWB$jtemp, DailyWB$SNOW, DailyWB$MELT)
    DailyWB$W = DailyWB$MELT + DailyWB$RAIN
    if(PET_Method == "Hamon"){
      DailyWB$PET = ET_Hamon_daily(DailyWB)
    } else {
      if(PET_Method == "Penman-Monteith"){
        DailyWB$PET = ET_PenmanMonteith_daily(DailyWB)
      } else {
        if(PET_Method == "Oudin"){
          DailyWB$PET = get_OudinPET(DailyWB$doy, point$y, DailyWB$PACK, 
                                     DailyWB$tmean_C, point$Slope, 
                                     point$Aspect, point$Shade.Coeff)
        } else {
          print("Error - PET method not found")
        }
      }
    }
    #DailyWB$PET_mod = modify_PET(DailyWB$PET, DailyWB$Slope, DailyWB$Aspect, 
    #                         DailyWB$Lat, DailyWB$Shade.Coeff)
    DailyWB$PET_mod <- DailyWB$PET * PET_mult
    DailyWB$W_PET = DailyWB$W - DailyWB$PET_mod
    DailyWB$SOIL = get_soil(DailyWB$W, point$Soil.Init, DailyWB$PET_mod,
                            DailyWB$W_PET, point$SWC.Max)
    DailyWB$DSOIL = diff(c(point$Soil.Init, DailyWB$SOIL))
    DailyWB$AET = get_AET(DailyWB$W, DailyWB$PET_mod, DailyWB$SOIL, point$Soil.Init)
    DailyWB$W_ET_DSOIL = DailyWB$W - DailyWB$AET - DailyWB$DSOIL
    DailyWB$D = DailyWB$PET_mod - DailyWB$AET
    DailyWB$GDD = get_GDD(DailyWB$tmean_C, T.Base)
    
    DailyWB_ret[[ct]] <- DailyWB %>%
      ungroup() %>%
      dplyr::select(date, x, y, GCM, pt_num, ppt_mm, 
                    "RUNOFF" = W_ET_DSOIL, RAIN, SNOW, MELT,AET,tmean_C) %>%
      pivot_longer(-c(date,x,y,pt_num,GCM), 
                   values_to = "vals", 
                   names_to = "vars") %>%
      mutate(site = point$site)
  }
}
   
# Group and summarize all runs
    DailyWB_ret2 <- DailyWB_ret %>% 
      bind_rows() %>%
      mutate(vals = ifelse(vars == "tmean_C", vals, vals /25.4)) %>% # mm to in
      group_by(date,vars,site,GCM) %>%
      dplyr::select(-c(x,y,pt_num)) %>%
      dplyr::summarize(vals = mean(vals, na.rm = TRUE),
                       .groups = "keep") %>%
       pivot_wider(names_from = vars, values_from = vals) %>%
    rename(., c("RUNOFF" = "runoff_in_wbm", 
                "RAIN" = "rain_in_wbm",
                "SNOW" = "snow_in_wbm",
                "MELT" = "melt_in_wbm",
                "AET" = "aet_in_wbm",
                "ppt_mm" = "precip_in_wbm")) 
  }


  


```

Run WBM for all points - returns spatially averaged daily value.

```{r wbm_run}

# run wbm - results returned in in/day
source_hist_wbm <- run_NPS_wbm(points = source_hist_pts,
                        climate_data = clim_source_hist)

source_fut_wbm <- run_NPS_wbm(points = source_fut_pts,
                              climate_data = clim_source_fut)

source_wbm <- bind_rows(source_hist_wbm, source_fut_wbm) %>%
  left_join(., select_cfs %>% 
              dplyr::select(GCM,CF) %>%
              dplyr::mutate(GCM = str_extract(GCM, "^[^.]+")), 
            by = "GCM") %>%
  dplyr::mutate(CF = ifelse(is.na(CF),"GridMET",CF))

source_wbm_annual <- source_wbm %>%
  ungroup %>%
  dplyr::mutate(year = year(date)) %>%
  dplyr::select(-date) %>%
  group_by(year,site,GCM) %>%
  dplyr::summarise(melt_in_wbm = sum(melt_in_wbm),
                   rain_in_wbm = sum(rain_in_wbm),
                   runoff_in_wbm = sum(runoff_in_wbm),
                   snow_in_wbm = sum(snow_in_wbm),
                   precip_in_wbm = sum(precip_in_wbm),
                   aet_in_wbm = sum(aet_in_wbm),
                   tmean_C = mean(tmean_C, na.rm = TRUE),
                   .groups = "keep") %>%
  mutate(run_per = runoff_in_wbm/precip_in_wbm)

ggplot(source_wbm_annual %>%
         pivot_longer(., -c(year,site,GCM),
                      names_to = "vars",
                      values_to = "vals"),
       aes(x = year, y = vals, color = vars)) +
         geom_line()

ggplot(source_wbm_annual %>% dplyr::filter(precip_in_wbm > 5),
       aes(x = precip_in_wbm - aet_in_wbm, y = runoff_in_wbm)) +
         geom_point()


rm("source_hist_wbm","source_fut_wbm")

ggplot(source_wbm, 
       aes(x = date, y = precip_in_wbm, color = CF)) + 
   geom_line() +
  theme_bw() +
  scale_color_manual("",values = c("black","red3","dodgerblue2"))

```


Compare gw levels to climate
```{r}
 
cum_depart <- function(x) {
  
  # if NA values, fill. If fist
  # val is NA, replace with first 
  # non-NA value.
  if (is.na(x[1])) {
    x[1] <- first(x[!is.na(x)])
  }
  x <- zoo::na.approx(x, na.rm = FALSE)
  mean_x <- mean(x, na.rm = TRUE)
  dep <- x - mean_x
  
  cum_dep <- cumsum(dep)
}

# Calculate daily median precipitation
departures <- source_wbm %>%
  ungroup() %>%
  left_join(., well_data %>% dplyr::filter(well == "Well 1"), by = "date") %>%
  dplyr::mutate(y = year(date)) %>%
  dplyr::filter(y > 2003,
                y < 2024) %>%
  dplyr::group_by(y) %>%
  dplyr::summarize(precip = sum(precip_in_wbm, na.rm = TRUE),
                   temp = mean(tmean_C, na.rm = TRUE),
                   gw = mean(static_ft, na.rm = TRUE),
                   melt = sum(melt_in_wbm, na.rm = TRUE),
                   rain = sum(rain_in_wbm, na.rm = TRUE),
                   runoff = sum(runoff_in_wbm, na.rm = TRUE)) %>%
  ungroup() %>%
  dplyr::mutate(melt_dep = cum_depart(melt),
                precip_dep = cum_depart(precip),
                temp_dep = cum_depart(temp),
                gw_dep = cum_depart(gw),
                melt_dep = cum_depart(melt),
                rain_dep = cum_depart(rain),
                runoff_dep = cum_depart(runoff)) 

ggplot(departures) +
  geom_line(aes(x = y, y = precip_dep, color = "Precip"), lwd = 1) + 
  geom_line(aes(x = y, y = gw_dep, color = "GW Depth"), lwd = 2) + 
  #eom_line(aes(x = y, y = temp_dep, color = "Temp C"), lwd = 1) +
  geom_line(aes(x = y, y = melt_dep, color = "Snowmwelt"), lwd = 1) +
  #geom_line(aes(x = y, y = rain_dep, color = "Rain"), lwd = 1) +
  #geom_line(aes(x = y, y = runoff, color = "Runoff"), lwd = 1) +
  theme_bw() + 
  scale_color_manual("", values = c("black","tomato", "dodgerblue","seagreen","pink2","orange")) +
  labs(y = "Cumulative Departure from Mean over Plotted POR")

ggplot(departures) + 
  geom_line(aes(x = y, y = gw, color = "GW"), lwd = 1) +
  geom_line(aes(x = y, y = melt, color = "Snowmelt"), lwd = 1) +
  geom_line(aes(x = y, y = rain, color = "Rain"), lwd = 1) +
  geom_line(aes(x = y, y = runoff, color = "Runoff"), lwd = 1) +
  #geom_line(aes(x = y, y = )) +
  theme_bw() +
  scale_color_manual("", values = c("black","dodgerblue", "tomato", "pink2")) 


departures %>%
  dplyr::select(c(gw_dep,precip_dep,temp_dep,melt_dep,rain_dep)) %>%
  pivot_longer(-gw_dep, names_to = "var", values_to = "value") %>%
  ggplot(aes(x = value, y = gw_dep)) +
    geom_point() +
    stat_smooth(method = "lm") +
    facet_wrap(~ var, scales = "free") +
    theme_bw()


ggplot(clim_dep %>% 
         dplyr::filter(y > 2000),
       aes(x = ppt_dep_cum/100, y = static_ft)) +
  geom_point() + 
  geom_smooth() +
  theme_bw()

# Join with original data
clim_gw <- clim_source_hist %>%
  dplyr::mutate(doy = yday(date))
  left_join(daily_median, by = "day_of_year")

# Calculate departure and cumulative departure
df <- df %>%
  mutate(departure = precipitation - median_precip,
         cumulative_departure = cumsum(departure))

# Remove unnecessary column
df <- df %>%
  select(-day_of_year)


gw_clim <- clim_source_hist %>%
  left_join(., well_data %>% dplyr::filter(well == "Well 1"), by = "date") %>%
  dplyr::mutate(day_of_year = yday(date),
                median_ppt = ppt_mm[match(day_of_year, yday(unique(date)))]) %>%
  dplyr::mutate(ppt_departure = ppt_mm - median_ppt,
                cum_departure = cumsum(ppt_departure))
 

ggplot(gw_clim) +
  geom_line(aes(x = date, y = cum_departure)) +
  geom_line(aes(x = date, y = static_ft))

```


###10. NWIS WBM Runoff Routing


```{r fit_functions}
# Define some objective functions for runoff routing Nash-Sutcliffe efficiency
NSE <- function(sim, obs) {
    1 - sum((sim - obs)^2, na.rm = TRUE) / 
    sum((obs - mean(obs, na.rm = TRUE))^2, na.rm = TRUE)
  }

SSE <- function(sim, obs) {
  sum((sim - obs)^2,
      na.rm=TRUE)
}

# RMSE
RMSE <- function(sim, obs) {
  squared_diff <- (sim - obs)^2
  return(sqrt(mean(squared_diff, na.rm = TRUE)))
}

MAE <- function(sim,obs) {
  mean(abs(sim - obs), na.rm = TRUE)
}

RSR <- function(sim,obs) {
  abs(sqrt(sum((obs-sim)^2, na.rm = TRUE))) / abs(sqrt(sum((obs-mean(obs))^2, na.rm = TRUE)))
}
  
PBIAS <- function(sim,obs) {
  abs((sum(obs-sim, na.rm = TRUE) * 100) / sum(obs, na.rm = TRUE))  
} 

# coefficient of determination (R^2)
COD <- function (sim,obs) {
  abs(sum((obs-mean(obs, na.rm = TRUE)) * (sim - mean(sim, na.rm = TRUE)), na.rm = TRUE) / (
             sqrt(sum((obs-mean(obs, na.rm = TRUE))^2, na.rm = TRUE)) * sqrt(sum((sim-mean(sim, na.rm = TRUE))^2, na.rm = TRUE)))) ^2
}

```



```{r nwis_wbm}

# Run WBM for nearest nwis watershed
nwis_wbm <- run_NPS_wbm(points = nwis_pts,
                        climate_data = clim_nwis,
                        hock_coef = 2,
                        PET_mult = 2,
                        SOIL_mult = 15) %>%
  left_join(., nwis_nearest_discharge, by = c("date","site"="site_no")) %>%
  ungroup()

# Example routing fun:
test_dates <- interval(as.Date("1995-01-01"), as.Date("2005-01-01"))
test_dat <- nwis_wbm %>%
  dplyr::filter(date %within% test_dates)

val_dates <- interval(as.Date("2005-01-01"), as.Date("2015-01-01"))
val_dat <- nwis_wbm %>%
  dplyr::filter(date %within% val_dates)

# Now, calibrate routing fun

# Fitting function for calibration
fit_fun <- function(params, 
                    dat = test_dat, 
                    return_dat = FALSE) {
  
  #params <- c(3,90,.5,50,1)
  #dat <- nwis_wbm
  
  #Q_mod <-runoff_routing_fun(df = dat, 
  #                           tau_q = params[1], 
  #                           tau_s = params[2], 
  #                           vs = params[3],
  #                           delay = params[4])
  
  Q_mod <-runoff_routing_snow_fun(df = dat, 
                             tau_q_rain = params[1], 
                             tau_s_rain = params[2], 
                             vs_rain = params[3],
                             tau_s_melt = params[4],
                              delay = params[5]
                            )
  
  df_out <- left_join(Q_mod, dat, by = "date") %>%
    drop_na(discharge_in_nwis)
  
  ret_er <- NSE(sim = df_out$Q_tot, obs = df_out$discharge_in_nwis)
  #ret_er <- SSE(sim = Q_mod$Q_tot, obs = discharge)
  #ret_er <- MAE(sim = Q_mod$Q_tot, obs = discharge)
  
  print(ret_er)
  
  if(return_dat==TRUE){
    Q_mod <- df_out %>% dplyr::select(date,Q_tot,discharge = discharge_in_nwis)
    return(Q_mod) 
  } else {
    return(ret_er)
  }
} 


 # daily data
  #               tau_qr, tau_sr, vsr, Tau_sm, delay
 lower_bounds <- c(  1,    30,   0.01,   10,   0)#,  0.01)
      initial <- c(  5,    80,   0.3,    90,   0)#,  0.5)
upper_bounds <- c(   30,  200,   0.9,   150,  31)#,   1)

# daily data
  #               tau_qr, tau_sr, vsr,  delay
# lower_bounds <- c(  1,    10,   0.01,     0)#,  0.01)
#      initial <- c(  5,    80,   0.3,      1)#,  0.5)
#upper_bounds <- c(   10,  150,   0.9,    31)#,   1)



# tau_q, tau_s, vs, delay, loss
optim_par <- 
  optim(
    par = initial, 
    fn = fit_fun,
    method = 'L-BFGS-B',
    lower = lower_bounds, 
    upper = upper_bounds,
    control = c("trace" = 0, "factr" = 1e-6, fnscale = -1))# function

print(optim_par$par)

mod_dis <- fit_fun(dat = test_dat,
                   params = optim_par$par,
                   return_dat = TRUE)


# https://www.hec.usace.army.mil/confluence/hmsdocs/hmstrm/calibration/calibration-summary-statistics
ggplot(mod_dis) +
  geom_line(aes(x = date, y = discharge, color = "NWIS")) +
  geom_line(aes(x = date, y = Q_tot, color = "Modeled")) +
  theme_bw() +
  scale_color_manual("",values = c("tomato","black")) +
  labs(title = paste0("    NSE: ", 
                      round(NSE(sim = mod_dis$Q_tot, obs = mod_dis$discharge),5),
                      "\n    RSR: ", 
                      round(RSR(sim = mod_dis$Q_tot, obs = mod_dis$discharge),5),
                      "\nP BIAS: ",
                      round(PBIAS(sim = mod_dis$Q_tot, obs = mod_dis$discharge),2),
                      "\n    COD: ",
                      round(COD(sim = mod_dis$Q_tot, obs = mod_dis$discharge),5)))











mod_val <- runoff_routing_snow_fun(df = val_dat,
                   tau_q_rain = optim_par$par[1],
                   tau_s_rain = optim_par$par[2],
                   tau_s_melt = optim_par$par[4],
                   vs_rain = optim_par$par[3],
                   delay = optim_par$par[5]) %>%
  left_join(., val_dat, by = "date") 
  

  
ggplot(mod_val) +
  #geom_line(aes(x = date,y = runoff, color = "WBM Runoff")) +
  geom_line(aes(x = date, y = Q_tot, color = "Routed Discharge")) +
  geom_line(aes(x = date, y = discharge_in_nwis, color = "NWIS")) +
  theme_bw() +
  labs(title = paste0("NSE: ", 
                      round(NSE(sim = mod_dis$Q_tot, obs = mod_dis$discharge_in_nwis),5))) +
  scale_color_manual("", values = c("black","red","lightgray")) 
  

```


```{r fit_to_gw_lev}

source_dates <- interval(as.Date("2004-01-01"), as.Date("2023-01-01"))
source_dat <- source_wbm %>%
  data.table() %>%
  dplyr::filter(date %within% source_dates) %>%
  left_join(., well_data %>% dplyr::filter(well == "Well 1"), by = "date") 




# Fitting function for calibration
fit_fun_gw <- function(params, 
                    dat = source_dat, 
                    return_dat = FALSE) {
  
  #params <- c(3,90,.5,50,1)
  #dat <- source_dat
  
  # Clean gw level data for calibration - assume linear
  # interpolation through time is okay 
  gw_lev <- dat[["static_ft"]] 
  if (is.na(gw_lev[1])) {
    gw_lev[1] <- first(gw_lev[!is.na(gw_lev)])
  }
  
  if (is.na(gw_lev[length(gw_lev)])) {
    gw_lev[length(gw_lev)] <- last(gw_lev[!is.na(gw_lev)])
  }
  
  gw_lev <- zoo::na.approx(gw_lev, na.rm = FALSE)
  gw_lev <- gw_lev - gw_lev[1]
  
  gw_lev <- gw_lev / 250
  
  
  dat$gw_clean <- gw_lev
  
  Q_mod <-runoff_routing_fun(df = dat, 
                             tau_q = params[1], 
                             tau_s = params[2], 
                             vs = params[3],
                              delay = params[4]
                            )
  
  df_out <- left_join(Q_mod, dat, by = "date")
  
  ret_er <- NSE(sim = df_out$Q_tot, obs = df_out$gw_clean)
  #ret_er <- SSE(sim = Q_mod$Q_tot, obs = discharge)
  #ret_er <- MAE(sim = Q_mod$Q_tot, obs = discharge)
  
  print(ret_er)
  
  if(return_dat==TRUE){
    Q_mod <- df_out %>% dplyr::select(date,Q_tot, gw_clean)
    return(Q_mod) 
  } else {
    return(ret_er)
  }
} 


 # daily data
  #               tau_qr, tau_sr, vsr, Tau_sm, delay
 lower_bounds <- c(  30,    60,   0.89,     0)#,  0.01)
      initial <- c(  50,    150,   0.9,     0)#,  0.5)
upper_bounds <- c(   90,  360,   0.99,   31)#,   1)

# daily data
  #               tau_qr, tau_sr, vsr,  delay
# lower_bounds <- c(  1,    10,   0.01,     0)#,  0.01)
#      initial <- c(  5,    80,   0.3,      1)#,  0.5)
#upper_bounds <- c(   10,  150,   0.9,    31)#,   1)



# tau_q, tau_s, vs, delay, loss
optim_par <- 
  optim(
    par = initial, 
    fn = fit_fun_gw,
    method = 'L-BFGS-B',
    lower = lower_bounds, 
    upper = upper_bounds,
    control = c("trace" = 0, "factr" = 1e-6, fnscale = -1))# function

print(optim_par$par)

source_lev <- fit_fun_gw(dat = source_dat,
                   params = optim_par$par,
                   return_dat = TRUE)


# https://www.hec.usace.army.mil/confluence/hmsdocs/hmstrm/calibration/calibration-summary-statistics
ggplot(source_lev) +
  geom_line(aes(x = date, y = gw_clean, color = "NWIS")) +
  geom_line(aes(x = date, y = cum_depart(Q_tot)/200, color = "Modeled")) +
  theme_bw() +
  scale_color_manual("",values = c("tomato","black")) +
  labs(title = paste0("    NSE: ", 
                      round(NSE(sim = mod_dis$Q_tot, obs = mod_dis$discharge),5),
                      "\n    RSR: ", 
                      round(RSR(sim = mod_dis$Q_tot, obs = mod_dis$discharge),5),
                      "\nP BIAS: ",
                      round(PBIAS(sim = mod_dis$Q_tot, obs = mod_dis$discharge),2),
                      "\n    COD: ",
                      round(COD(sim = mod_dis$Q_tot, obs = mod_dis$discharge),5)))











source_val <- runoff_routing_snow_fun(df = source_dat,
                   tau_q_rain = optim_par$par[1],
                   tau_s_rain = optim_par$par[2],
                   tau_s_melt = optim_par$par[4],
                   vs_rain = optim_par$par[3],
                   delay = optim_par$par[5]) %>%
  left_join(., source_dat, by = "date") %>%
  left_join(., well_data %>% dplyr::filter(well == "Well 1"), by = "date") %>%
  dplyr::mutate(dis_dep = cum_depart(Q_tot),
                gw_dep = cum_depart(static_ft))


ggplot(source_val) +
  #geom_line(aes(x = date,y = runoff, color = "WBM Runoff")) +
  geom_line(aes(x = date, y = dis_dep-6.5, color = "Routed Discharge")) +
  geom_line(aes(x = date, y = static_ft, color = "Well")) +
  theme_bw() +
  scale_color_manual("", values = c("black","red","lightgray")) 


```



```{r nwis_wbm}

# Run WBM for nearest nwis watershed


# Define some objective functions for runoff routing Nash-Sutcliffe efficiency
NSE <- function(sim, obs) {
    1 - sum((sim - obs)^2, na.rm = TRUE) / 
    sum((obs - mean(obs, na.rm = TRUE))^2, na.rm = TRUE)
  }

SSE <- function(sim, obs) {
  sum((sim - obs)^2,
      na.rm=TRUE)
}

# RMSE
RMSE <- function(sim, obs) {
  squared_diff <- (sim - obs)^2
  return(sqrt(mean(squared_diff, na.rm = TRUE)))
}

MAE <- function(sim,obs) {
  mean(abs(sim - obs), na.rm = TRUE)
}

RSR <- function(sim,obs) {
  abs(sqrt(sum((obs-sim)^2, na.rm = TRUE))) / abs(sqrt(sum((obs-mean(obs))^2, na.rm = TRUE)))
}
  
PBIAS <- function(sim,obs) {
  abs((sum(obs-sim, na.rm = TRUE) * 100) / sum(obs, na.rm = TRUE))  
} 

# coefficient of determination (R^2)
COD <- function (sim,obs) {
  abs(sum((obs-mean(obs, na.rm = TRUE)) * (sim - mean(sim, na.rm = TRUE)), na.rm = TRUE) / (
             sqrt(sum((obs-mean(obs, na.rm = TRUE))^2, na.rm = TRUE)) * sqrt(sum((sim-mean(sim, na.rm = TRUE))^2, na.rm = TRUE)))) ^2
}



# Example routing fun:
test_dates <- interval(as.Date("1990-01-01"), as.Date("1995-01-01"))
test_dat <- nwis_wbm %>%
  dplyr::filter(date %within% test_dates)

#mod_dis <- runoff_routing_fun(df = test_dat,
#                   tau_q = 10,
#                   tau_s = 50,
#                   vs = .7,
#                   delay = 10) %>%
#  left_join(., test_dat, by = "date") 

mod_dis <- runoff_routing_snow_fun(df = test_dat,
                   tau_q_rain = 10,
                   tau_s_rain = 100,
                   tau_s_melt = 50,
                   vs_rain = .1,
                   delay = 10) %>%
  left_join(., test_dat, by = "date") 
  

  
ggplot(mod_dis) +
  #geom_line(aes(x = date,y = runoff, color = "WBM Runoff")) +
  geom_line(aes(x = date, y = Q_tot, color = "Routed Discharge")) +
  geom_line(aes(x = date, y = discharge_in_nwis, color = "NWIS")) +
  theme_bw() +
  labs(title = paste0("NSE: ", 
                      round(NSE(sim = mod_dis$Q_tot, obs = mod_dis$discharge_in_nwis),5))) +
  scale_color_manual("", values = c("black","red","lightgray")) 
  





# Now, calibrate routing fun

# Fitting function for calibration
fit_fun_all <- function(params, 
                    points = nwis_pts,
                    climate_data = clim_nwis,
                    discharge_data = nwis_nearest_discharge,
                    return_dat = FALSE) {
  
  
  #params <- c(19,150,.01,45,1.5,5)
  #points <- nwis_pts
  #climate_data <- clim_nwis
  #discharge_data <- nwis_nearest_discharge
  
  
  wbm <- run_NPS_wbm(points = points,
                     climate_data = climate_data,
                     hock_coef = 3,
                     PET_mult = params[5],
                     SOIL_mult = params[6]) %>%
  left_join(., discharge_data, by = c("date","site"="site_no")) %>%
  ungroup()
  
  Q_mod <-runoff_routing_snow_fun(df = dat, 
                             tau_q_rain = params[1], 
                             tau_s_rain = params[2], 
                             vs_rain = params[3],
                             tau_s_melt = params[4],
                              delay = 5,
                            )
  
  df_out <- left_join(Q_mod, dat, by = "date") %>%
    drop_na(discharge_in_nwis)
  
  ret_er <- NSE(sim = df_out$Q_tot, obs = df_out$discharge_in_nwis)
  #ret_er <- SSE(sim = Q_mod$Q_tot, obs = discharge)
  #ret_er <- MAE(sim = Q_mod$Q_tot, obs = discharge)
  
  print(ret_er)
  
  if(return_dat==TRUE){
    Q_mod <- df_out %>% dplyr::select(date,Q_tot,discharge = discharge_in_nwis)
    return(Q_mod) 
  } else {
    return(ret_er)
  }
} 


 # daily data
  #               tau_qr, tau_sr, vsr, Tau_sm, PET_mult, SOIL_mult
 lower_bounds <- c(  20,    140,   0.01,   40,   1, 1)#,  0.01)
      initial <- c(  25,    145,   0.1,    45,   1.5, 5)#,  0.5)
upper_bounds <- c(   30,  150,   0.2,   50,  2,  10)#,   1)


# tau_q, tau_s, vs, delay, loss
optim_par <- 
  optim(
    par = initial, 
    fn = fit_fun_all,
    method = 'L-BFGS-B',
    lower = lower_bounds, 
    upper = upper_bounds,
    control = c("trace" = 0, "factr" = 1e-6, fnscale = -1))# function

print(optim_par$par)

mod_dis <- fit_fun(dat = test_dat,
                   params = optim_par$par,
                   return_dat = TRUE)


# https://www.hec.usace.army.mil/confluence/hmsdocs/hmstrm/calibration/calibration-summary-statistics
ggplot(mod_dis) +
  geom_line(aes(x = date, y = discharge, color = "NWIS")) +
  geom_line(aes(x = date, y = Q_tot, color = "Modeled")) +
  theme_bw() +
  scale_color_manual("",values = c("tomato","black")) +
  labs(title = paste0("    NSE: ", 
                      round(NSE(sim = mod_dis$Q_tot, obs = mod_dis$discharge),5),
                      "\n    RSR: ", 
                      round(RSR(sim = mod_dis$Q_tot, obs = mod_dis$discharge),5),
                      "\nP BIAS: ",
                      round(PBIAS(sim = mod_dis$Q_tot, obs = mod_dis$discharge),2),
                      "\n    COD: ",
                      round(COD(sim = mod_dis$Q_tot, obs = mod_dis$discharge),5)))

```


```{r water_runoff}
# Explore source of water contributing to runoff
ggplot(test_dat) + 
  geom_line(aes(x = date, y = rain_in_wbm, color = "Rain"),alpha = 0.8) + 
  geom_line(aes(x = date, y = runoff_in_wbm, color = "Runoff"), alpha = 0.7,lwd=2) + 
  geom_line(aes(x = date, y = melt_in_wbm, color = "Snowmelt"), alpha = 1) + 
  geom_line(aes(x = date, y = snow_in_wbm, color = "Snow"), alpha = 1) +
  
  geom_line(aes(x = date, y = discharge_in_nwis, color = "NWIS Discharge")) +
  theme_bw() +
  labs(y = "Mammoth Creek Hydrology (in/day)", x = "")+
  scale_color_manual("", values = c("black","dodgerblue","gray","tomato","green"))
```

```{r 30_year_mean_fig}
# Also import 30 year WBM stats
## list of variables to map function over
variables <- c("runoff", "accumswe", "AET", "soil_water")
cf <- select_cfs$GCM
scen <- select_cfs$CF

wbm_30y <- 
  map(variables, 
      ~get30yearWBMGridMET(aoi = st_buffer(park_boundary, 0.2),
                          variable = .x,
                          cf = cf,
                          save = FALSE
                         #path = "data/all",
                         #filename_prefix = "BRCA"
                          )
      )

wbm_30y <- terra::rast(wbm_30y)
# manually save for now, but going to save variable with report data .Rdata
 writeRaster(
      wbm_30y,
      filename =  "data/park/BRCA/BRCA_wbm_30yr_annual_rasters.tif",
      overwrite = TRUE
    )

### In the future, we'll get WBM data for the watersupply watershed.
# Here is the code to do that as of now -- can probably be sped up.
 
# First download wbm data for the watersupply watershed.
# This took an hour and 10 minutes for the BRCA watershed, so only do this
# again if necessary.
 
ws_wbm <- 
  get_wbm_aoi(park,
              aoi = watersupply_watershed %>% 
                st_union(), 
              aoi_name = "watersupply_watershed", download = FALSE) 
                      # rename if joining to other centroid_wbm%>%
                      #  dplyr::rename_with(~ paste0(.,"_ws"), -c(date,gcm))
 
```


### 11. Park Visitation

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}
# NPS monthly visitor information
visitors <- 
  getUnitVisitation(units = park, startYear = 1980, endYear = 2023) %>%
  dplyr::mutate(ym = ym(paste0(Year, "-", Month))) %>%
  dplyr::mutate(TotalVisitors = RecreationVisitors + NonRecreationVisitors) %>%
  dplyr::select(ym, RecreationVisitors, TotalVisitors) %>%
  mutate(ifelse(TotalVisitors == 0,NA,TotalVisitors),
         ifelse(RecreationVisitors ==0, NA, RecreationVisitors))


```

### 12. Water use data

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

# Get state specific water use data --> in monthly format

if (state == "UT") {

  water_supply_id <- getWaterSuppliersUtah(aoi = park_boundary) %>%
    filter(grepl("National", WRNAME, ignore.case=TRUE) | 
           grepl("National", WRENAME, ignore.case = TRUE)) %>%
    .$WRID

  if (!sum(water_supply_id)==0) {
  
   water_use <- map_dfr(water_supply_id, 
                     \(x) getWaterUseUtah(WRID = x)[[1]] %>%
      dplyr::filter(!is.na(suppressWarnings(as.numeric(Year)))) %>%
      tidyr::pivot_longer(-c("Year","Method of Measurement"), 
                          names_to = "month", 
                          values_to = "use_acre_feet") %>%
      dplyr::filter(month != "Annual inAcre Feet") %>%
      dplyr::mutate(ym = ym(paste0(Year, "-", month))) %>%
      drop_na(ym) %>%
      dplyr::group_by(ym) %>%
      dplyr::summarize(use_acre_feet = sum(as.numeric(use_acre_feet), 
                                           na.rm = TRUE)) %>%
        mutate(WRID=paste0("WRID_",x))) %>%
     pivot_wider(names_from = WRID, values_from = use_acre_feet) %>%
     mutate(use_acre_feet = rowSums(dplyr::select(., !starts_with("ym")), 
                                    na.rm = TRUE))
  
  } else if (water_supply_id == 0 ) {
    water_use = Visitors %>%
      mutate(water_use_gal = TotalVisitors*5)
    }

}

# Plot monthly water use
ggplot(water_use %>% 
         dplyr::mutate(month = month(ym)) %>% 
         group_by(month) %>% 
         dplyr::select(-ym) %>% 
         dplyr::summarize(use_acre_feet = sum(use_acre_feet, na.rm = TRUE),.groups = "keep"), 
       aes(x = month, y = use_acre_feet)) + 
  geom_line() + 
  theme_bw() + 
  labs(y = "Water Use (acre-feet)")

```

### 13. Data Analysis

  tbd...

### 14.  Example Tables

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}


kable(select_cfs, escape = FALSE, booktabs = T,
     digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
kableExtra::landscape() %>%
  #kable_styling(full_width = F) %>%
    kable_paper(full_width = F)
```


