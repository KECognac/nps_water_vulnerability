---
title: "Generic_CCVA"
author: "KEC"
date: "2024-04-04"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source('setup.R')
```

## R Markdown

This document prepares data inputs for the generic CCVA for water supplies at each National Park.

## User Input

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

# Identify park by 4 digit code 
# (https://www.nps.gov/aboutus/foia/upload/NPS-Unit-List.xlsx)
park <- "BRCA"

```

## Download data

Download necessary data from publicly available sources.

##### Park boundary, watersheds and NHD flowlines

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

# Get park boundary
park_boundary <- getParkBoundary(park = park)

# Get watersheds within park boundary
park_watershed <- getWatersheds(aoi = park_boundary, 
                                save = FALSE)

# Get flowlines within park boundary
park_flowlines <- park_watershed %>%
            dplyr:: summarize() %>%
            mapNHDPlusHR() %>%
            dplyr:: summarize()

```

#### Points of diversion and water supply for park

Park water supplies may be sourced from within or beyond the park boundary. This chunk pulls in state-reported water supply locations that occur within a buffer distance from both the park boundary. It also pulls in the watersheds that intersect with those points. Because water supply locations are reported by state, state-specific functions are utilized.

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

# ****KEC: This should be nested into a getPODall function with aoi and dist
# args which then applies the state-specific function.

# Get state specific points of diversion (POD) (i.e., water supply points)
buffer_dist <- 0.1 # in decimal degrees lat/long

# State specific functions - need to make for rest of states
if (park_boundary$STATE == "AL") {}

if (park_boundary$STATE == "CA") {
  POD_state <- getPODCalifornia(aoi = park_watershed, 
                                dist = buffer_dist)
} else if (park_boundary$STATE == "NV") {
  POD_state <- getPODNevada(aoi = park_watershed, 
                            dist = buffer_dist)
} else if (park_boundary$STATE == "UT") {
  POD_state <- getPODUtah(aoi = park_watershed, 
                          dist = buffer_dist)
} 

# Now, if POD are available, identify potential water supply from those 
# state-wide PODs.
#         - For some parks, the water supply ID is known.  Select the known
#           supply by ID for those parks.
#         - Where it is unknown, assume the water supply is any POD owned by
#           NPS and located within the buffer distance.

# ****KEC: This assumes POD_state has "OWNER" column and that NPS is identified 
# by string "NATIONAL PARK". Should probably update match strings in future as 
# other POD databases are brought in. 

# ****KEC: Do we keep irrigation, stockwatering, and/or power supply wells?

if (!is_empty(POD_state)) {
# Utah col descriptions for POD_supply 
#.  -> https://www.arcgis.com/sharing/rest/content/items/5d530e62e6ca42528dd13e0a453a3b73/info/metadata/metadata.xml?format=default&output=html
# Some states have a known supply. If so, assign.
if (park == "BRCA") {
    POD_supply <- POD_state %>%
    dplyr::filter(WRNUM %in% c("61-893", "2061001M00")) %>%
    dplyr::distinct(LOCATION, .keep_all = TRUE)
} else {
    POD_supply <- POD_state %>%
    dplyr::filter(OWNER %like% "NATIONAL PARK",
                  #USES %in% c("D","M","MO"),
                  str_detect(USES,"D|M|O")) %>% # municipal, domestic, or other
    dplyr::distinct(LOCATION, .keep_all = TRUE) %>%
      dplyr::distinct(WRNUM, .keep_all = TRUE)
}

# Get watershed intersecting each watersupply point
watersupply_watershed <- vector("list", nrow(POD_supply))  
  
for(i in 1:nrow(POD_supply)){
  watersupply_watershed[[i]] <- POD_supply[i,] %>% 
  getXYWatersheds(sf = ., coordinates = NULL)
}

watersupply_watershed <- watersupply_watershed %>%
  dplyr::bind_rows() %>% 
  dplyr::distinct(featureid, .keep_all = TRUE) 

# Get flowlines associated with watersupply watershed
watersupply_flowlines <- watersupply_watershed %>%
              dplyr::summarize() %>%
              mapNHDPlusHR()
}


```

#### Centroids

Climate futures have been previously compiled for park and Koppen centroids. Check which f these best represents conditions at the (potential) source(s) for the park's water supply.

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

# Get koppen climate grid for park with buffer
koppen_park <- get_koppen(park = park, 
                             aoi = park_boundary, 
                             buffer_dist = 0.1)


# Get koppen climate intersecting watershed
# create a merged watersupply watershed for subsequent functions
ws_union <- st_union(watersupply_watershed) %>%
            st_as_sf()

koppen_ws <- get_koppen(park = park, 
                           aoi = ws_union, 
                           buffer_dist = 0) %>%
            sf::st_transform(., crs = sf::st_crs(ws_union)) %>%
            dplyr::filter(st_intersects(., ws_union) %>% 
            as.logical())
            

# identify the koppen climate that spans the greatest number of cells
# in watershed area
koppen_ws_sel <- koppen_ws %>%
              dplyr::count(K_vals)

# Create a table of Koppen and park centroids with area span for each koppen
# climate that overlaps with watersupply watershed (from above) and distance
# between centroid location and watersupply watershed. 

#****KEC:  Note, nothing is done with this as of now, but we can incorporate 
#* later
url <- 'https://parkfutures.s3.us-west-2.amazonaws.com/maca-tprh-data/0Climate_Zones_by_Unit_cleaned.csv'
centroid_sel <- GET(url) %>% 
            as.character() %>% 
            data.table::fread(.,header = TRUE, skip = 1) %>%
            dplyr::filter(UNIT_CODE == park) %>%
            sf::st_as_sf(coords = c("Lon","Lat"), 
                        crs = sf::st_crs(watersupply_watershed)) %>%
            dplyr::mutate(dist = (sf::st_distance(geometry,ws_union))) %>%
            bind_rows(sf::st_centroid(park_boundary) %>% 
                      st_as_sf() %>%
                      dplyr::mutate(dist = (sf::st_distance(Shape, ws_union)))) %>%
            sf::st_set_geometry(., NULL) %>%
            dplyr::select(c(ClimateZone,dist)) %>%
            dplyr::mutate(CZ_str = sprintf("_%02d", ClimateZone),
                          CZ_str = str_replace(CZ_str, "_NA", ""),
                          centroid = paste0(park,CZ_str,"_future")) %>%
          dplyr::left_join(koppen_ws %>% dplyr::count(K_vals), 
                           by = c("ClimateZone" ="K_vals")) %>%
          dplyr::select(-CZ_str)


min_dist_cent <- centroid_sel[centroid_sel$dist == min(centroid_sel$dist)][[3]]
max_overlap_cent <- centroid_sel[centroid_sel$n == max(centroid_sel$n)][[3]]
```

#### Get Climate data for park centroid

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

# Import table of selected futures for site. Selections were made using the "select_GCMs" 
# function. 
select_cfs <- data.table::fread('data/parkwide_GCMs.csv') %>% 
              dplyr::filter(park %in% {{park}}) %>%
              # Uncomment either:
              # a. if using min distance to supply watershed 
              dplyr::filter(centroid == min_dist_cent)
              # or b.if using max overlap with supply watershed
              #dplyr::filter(centroid == max_overlap_cent)

# ****KEC: update function to check if files expist before downloading.
get_centroid_climate_data(park = park, save = TRUE)

# Directory to which files were downloaded.
climate_dir <- paste0("data/park/",park,"/centroid/climate")

# Import centroid climate data
centroid_climate <- base::list.files(climate_dir,full.names = TRUE) %>%
            purrr::map(~ read_csv(.x) %>% 
            dplyr::mutate(Unit_ClimateZone = str_remove_all(basename(.x),
                              "_(?<=_)(future|historical)\\.csv"))) %>%
            dplyr::bind_rows() %>%
            dplyr::left_join(select_cfs, by = "GCM") %>%
            dplyr::mutate(CF = ifelse(GCM %in% "gridmet.historical","hist",CF)) %>%
            janitor::clean_names() %>%
            dplyr::select(-c(park, delta_tavg,delta_pr)) 


```

#### WBM Data

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

# Download centroid data -- will need to update for each park
get_centroid_wbm_data(park = park)
    
## Note, currently getting an error with save = FALSE in function call

wbm_dir <- paste0("data/park/",park,"/centroid/wbm/")

centroid_wbm <- list.files(wbm_dir,full.names = TRUE) %>% 
            purrr::map(~ read_csv(.)) %>% 
            bind_rows() %>%
            left_join(select_cfs, by = "GCM") %>%
            dplyr::mutate(CF = ifelse(GCM %in% "gridmet.historical","hist",CF)) %>%
            janitor::clean_names() %>%
            dplyr::select(-c(park,lat,lon,delta_tavg,delta_pr, period))

```

#### Water use data

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

# Get state specific water use data --> in monthly format

if (park_boundary$STATE == "UT") {

  water_supply_id <- getWaterSuppliersUtah(aoi = park_boundary) %>%
    filter(grepl("National Park", WRNAME, ignore.case=TRUE)) %>%
    .$WRID

  # Park specific selections based on known ID
  
  if (park == "BRCA") {
    
    water_use_1 <- getWaterUseUtah(WRID = water_supply_id)[[1]] %>%
                  slice(1:39) %>%
                  pivot_longer(-c("Year", "Method of Measurement"), 
                               names_to = "month", 
                               values_to = "use_acre_feet") %>%
                  dplyr::mutate(ym = ym(paste0(Year, "-", month))) %>%
                  dplyr::filter(month != "Annual inAcre Feet") %>%
                  dplyr::select(ym, use_acre_feet) %>%
                  dplyr::mutate(well = "Well 1")
  
  # Well 2
  water_use_2 <- getWaterUseUtah(WRID = water_supply_id)[[1]] %>%
                  slice(51:nrow(.)) %>%
                  dplyr::filter(!is.na(as.numeric(Year))) %>%
                  pivot_longer(-c("Year", "Method of Measurement"), 
                               names_to = "month", 
                               values_to = "use_acre_feet") %>%
                  dplyr::mutate(ym = ym(paste0(Year, "-", month))) %>%
                  dplyr::filter(month != "Annual inAcre Feet") %>%
                  dplyr::select(ym, use_acre_feet) %>%
                  dplyr::mutate(well = "Well 2")
  
  # join water use data
  water_use <- water_use_1 %>%
              dplyr::bind_rows(water_use_2) %>%
              dplyr::group_by(ym) %>%
              dplyr::summarize(use_acre_feet = sum(as.numeric(use_acre_feet), 
                                                   na.rm = TRUE))
  
    rm(list = c("water_use_1", "water_use_2"))
  
  } else {
    
  # For UTAH parks without specific info on # of wells, etc, sum all
  # use for each month.
  water_use <- getWaterUseUtah(WRID = water_supply_id)[[1]] %>%
                dplyr::filter(!is.na(suppressWarnings(as.numeric(Year)))) %>%
                tidyr::pivot_longer(-c("Year","Method of Measurement"), 
                             names_to = "month", 
                             values_to = "use_acre_feet") %>%
                dplyr::filter(month != "Annual inAcre Feet") %>%
                dplyr::mutate(ym = ym(paste0(Year, "-", month))) %>%
                dplyr::group_by(ym) %>%
                dplyr::summarize(use_acre_feet = sum(as.numeric(use_acre_feet), 
                                                     na.rm = TRUE)) 
  }

}

```

##### USGS gages within the park or POD watershed

For many parks, the nearest USGS stream gage is far away. Therefore, we are pulling all NWIS gages within 100 km of the park boundary. Of those, we only select stream gages that are considered "reference" gages in the [GAGES-II database (Falcone, 2011)](https://pubs.usgs.gov/publication/70046617). Then, we delineate each of those gages' watersheds using the `get_nldi_basin()` function from the {nhdplusTools} package:

```{r, eval = TRUE, message = FALSE, warning = FALSE}

# Get all NWIS sites
nwis <- listNWIS(aoi = park_boundary, dist = .3) #%>%

  #dplyr::filter(data_type_cd == "dv",
  #       code == "00060")

# Get NWIS Stream Gages
ref_gages <- get_gagesII(id = nwis$site_no) %>%
             dplyr::filter(class == "Ref")

nwis_stream <- nwis %>%
              dplyr::filter(site_no %in% ref_gages$staid,
                            data_type_cd == "dv") %>%
              dplyr::left_join(st_drop_geometry(ref_gages), 
                               by = c("site_no" ="staid")) 

# Download data from reference stream sites
nwis_stream_discharge <- 
  dataRetrieval::readNWISdv(siteNumbers = nwis_stream$site_no,
                            parameterCd = c('00060','00065')) %>%
    dplyr::mutate(y = year(Date), m = month(Date)) %>%
    dplyr::filter(y >= 1980) %>%
    dplyr::group_by(y,m, site_no) %>%
    dplyr::summarize(mean_discharge = mean(X_00060_00003, na.rm. = TRUE)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(ym = lubridate::make_date(year = y, month = m, day = 1)) %>% 
    dplyr::select(ym, site_no, mean_discharge) %>%
    tidyr::pivot_wider(names_from = site_no, names_prefix = "gage_", values_from = mean_discharge) #%>%

# Download data from reference stream sites
#getNWIS(inventory = nwis_stream, park = "misc", path = "data/")


# Define functions to get those watersheds for ref. gages using get_nldi_basin 
# in from {nhdplusTools}.

# ================ Function to identify NLDI watersheds ========================

nldi_finder <- function(site_no) {
  
  nldi_nwis <- list(featureSource = "nwissite",
                    featureID = paste0("USGS-", site_no))
  
  gage_basin <- nhdplusTools::get_nldi_basin(nldi_feature = nldi_nwis) %>%
                              st_transform(., 4269) %>%
                              dplyr::mutate(site_no = site_no) %>%
                              suppressMessages() %>%
                              invisible()
  
  return(gage_basin)
  
}


# ================ Function to identify NLDI metadata ==========================

nldi_meta <- function(site_no){
  
  nldi_nwis <- list(featureSource = "nwissite",
                    featureID = paste0("USGS-", site_no))
  
  gage_basin <- nhdplusTools::get_nldi_characteristics(nldi_feature = nldi_nwis,
                                                       type = "total")[[1]] %>%
                dplyr::filter(characteristic_id %in% 
                        c("TOT_ELEV_MEAN", "TOT_ELEV_MAX", "TOT_ELEV_MIN")) %>%
                tidyr::pivot_wider(-percent_nodata, 
                                   values_from = characteristic_value, 
                                   names_from = characteristic_id)
  return(gage_basin)
  
}


# Now, use functions to get watersheds associated with stream gages
nldi_watershed <- nwis_stream$site_no %>%
                purrr::map_dfr(~nldi_finder(site_no = .)) %>%
                dplyr::mutate(data = map(site_no, ~nldi_meta(site_no = .))) %>%
                unnest() %>%
                dplyr::left_join(st_drop_geometry(nwis), by = "site_no")

nldi_flowlines <- dplyr::summarize(nldi_watershed) %>%
                  mapNHDPlusHR() %>% 
                  dplyr::summarize()


# Now Get Gw sites

nwis_groundwater <- nwis %>%
  dplyr::filter(begin_date != end_date,
         n_obs > 50,
         # groundwater sites only:
         site_type_cd == "GW",
         data_type_cd == "gw",
         code == 72019) %>%
  dplyr::mutate(dist = st_distance(geometry,park_boundary) %>%
                  as.numeric()) %>%
         dplyr::filter(dist <= 1600*3) %>%
  add_gw_meta()


# pull those sites groundwater level data
  nwis_groundwater_levels <- dataRetrieval::readNWISgwl(nwis_groundwater$site_no) %>%
    dplyr::filter(parameter_cd == 72019,
                  year(lev_dt) >= 1980) %>% # 72019 =Depths, 62611=elevation
    dplyr::mutate(ym = lubridate::ym(substr(lev_dt, 1, 7))) %>% 
    dplyr::group_by(ym, site_no) %>%
    dplyr::summarize(mean_lev_va = mean(lev_va, na.rm. = TRUE)) %>%
    dplyr::select(ym, site_no, mean_lev_va) %>%
    tidyr::pivot_wider(names_from = site_no, names_prefix = "well_", values_from = mean_lev_va) #%>%


```

#### Park Visitation

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}
# NPS monthly visitor information
visitors <- 
  getUnitVisitation(units = park, startYear = 1980, endYear = 2023) %>%
  dplyr::mutate(ym = ym(paste0(Year, "-", Month))) %>%
  dplyr::mutate(TotalVisitors = RecreationVisitors + NonRecreationVisitors) %>%
  dplyr::select(ym, RecreationVisitors, TotalVisitors)
```

## Begin data analysis

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}


## THis section is a WORK IN PROGRESS


# First Calculate some stats

hist_95th_pctl_pcp <- centroid_climate %>% 
  filter(gcm == "gridmet.historical") %>% 
  pull(precip_in) %>% 
  quantile(.95)

# Other stats??



# Now join datasets - for select gcms only

centroid_all <- left_join(centroid_climate %>%
                            dplyr::filter(!is.na(cf)), # removes non-selected
                          centroid_wbm %>%
                            dplyr::filter(!is.na(cf)), 
                by = c("date","gcm","cf", "centroid","unit_climate_zone")) %>%
  # Days with temp over 92 degrees F
  dplyr::mutate(days_gt_92F = case_when(tmax_f > 92 ~ 1,
                                tmax_f <= 92 ~ 0)) %>%
  # Days with temp less than 32 degrees F
  dplyr::mutate(days_lt_32F = case_when( tmin_f < 32 ~ 1,
                                  tmin_f >= 32 ~ 0)) %>%
  # Days with precipitation greater than historic 95th percentile
  dplyr::mutate(days_gt_95pcp = case_when(precip_in > hist_95th_pctl_pcp ~ 1,
                                 tavg_f <= hist_95th_pctl_pcp ~ 0))



# Now aggregate into monthly and yearly datasets.
# For temporal aggregations, some variables will be summarized using the mean 
# while others will use the sum. Define which cols for subsequent calculations
mean_cols <- c("tavg_f","tmax_f","tmin_f","r_hmax_percent","r_hmin_percent",
               "deficit_in","soil_water_in","runoff_in","accumswe_in")
sum_cols <- c("precip_in","rain_in","aet_in","pet_in","days_gt_92F",
              "days_lt_32F","days_gt_95pcp")

# Create Seasonal Dataframe
centroid_all_seasonal <- centroid_all %>%
  dplyr::mutate(season = case_when(month(date) %in% c(12,1,2) ~ "Winter",
                            month(date) %in% c(3,4,5) ~ "Spring",
                            month(date) %in% c(6,7,8) ~ "Summer",
                            month(date) %in% c(9,10,11) ~ "Fall")) %>%
  dplyr::mutate(y = year(date)) %>%
  dplyr::select(-c(date)) %>%
  dplyr::group_by(y,gcm,season)%>%
  dplyr::summarize(
              across(all_of(sum_cols),sum),  # Sum of columns in sum_cols list
              across(all_of(mean_cols),mean)) %>%
                  dplyr::mutate(y = make_date(y)) 
  
# Create Annual Dataframe
centroid_annual <- centroid_all  %>%
            dplyr::mutate(y = year(date)) %>%
            dplyr::select(-c(date)) %>%
            dplyr::group_by(y,gcm,unit_climate_zone,cf) %>%
            dplyr::summarize(
              across(all_of(sum_cols),sum),  # Sum of columns in sum_cols list
              across(all_of(mean_cols),mean)) #%>%
                  #dplyr::mutate(y = make_date(y)) 
 
# Create Monthly Dataframe
centroid_monthly <- centroid_all  %>%
            dplyr::mutate(y = year(date), m = month(date)) %>%
            dplyr::select(-c(date)) %>%
            dplyr::group_by(y,m,gcm,unit_climate_zone,cf) %>%
            dplyr::summarize(
              across(all_of(sum_cols),sum),  
              across(all_of(mean_cols),mean)) %>%
                  dplyr::mutate(ym = make_date(y,m), , .before = gcm) %>%
            dplyr::ungroup() %>%
            dplyr::select(-c(y,m)) %>%
  # Add other monthly datasets to monthly
  dplyr::left_join(nwis_groundwater_levels, by = c("ym")) %>%
  dplyr::left_join(nwis_stream_discharge, by = c("ym")) %>%
  dplyr::left_join(visitors, by = c("ym"))

# Calculate differential

# Define desired year ranges
future_years = 2035:2065
historic_years = 1979:2012

# Calculate future and historic means for each value.
future_stats <- centroid_annual %>%
  dplyr::filter(y %in% future_years) %>%  
  dplyr::group_by(gcm,unit_climate_zone, cf) %>%
  dplyr::summarise_if(is.numeric, mean, na.rm = TRUE)


historic_stats <- centroid_annual %>%
  dplyr::filter(y %in% historic_years) %>%  
  dplyr::group_by(gcm,unit_climate_zone, cf) %>%
  dplyr::summarise_if(is.numeric, mean, na.rm = TRUE)



```

## Optional Plot Data

```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}
# Optional view data

mapviewOptions(basemaps = c("Esri.WorldStreetMap", "Esri.WorldImagery","Esri.WorldShadedRelief"))

mapview(park_boundary, 
        col.regions = "#74a089", 
        alpha.regions = .5, 
        lwd = 2, 
        #popup = FALSE, 
        #legend = F, 
        homebutton = FALSE,
        layer.name = paste0(park," Park Boundary")) +
  mapview(park_watershed,
          col.regions= NA, 
          alpha.regions = 0, 
          lwd = .25, 
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE) +
  mapview(park_flowlines,
          col.regions = "darkblue",
          lwd = 0.5,
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE) +
  # UNCOMMENT IF AVAILABLE
  mapview(dplyr::summarize(watersupply_watershed),
          col.regions = "#E69F00", 
          alpha.regions = .5, 
          #popup = FALSE, 
          #legend = F, 
          homebutton = FALSE,
          layer.name = "Water Supply Watershed",
          legend = FALSE) +
  mapview(watersupply_flowlines,
          col.regions = "darkblue",
          lwd = 0.5,
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE) +
    mapview(nwis_groundwater,
            cex = 6,
            col.regions = c("#8C86A0"),
            label = FALSE,
            homebutton = FALSE,
            layer.name = "NWIS Wells") +
  mapview(nldi_watershed,
          col.regions= NA, 
          alpha.regions = 0, 
          lwd = .5,
          color = "#C0532B",
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE) +
  mapview(POD_supply,
          col.regions = c("#E69F00"), # orange
          alpha.regions = 1,
          alpha = 1,
          cex = 6, 
          layer.name = "Park Water Supply & Watershed",
          homebutton = FALSE,
          label = FALSE) +
  mapview(nwis_stream,
            cex = 6,
            col.regions = c("#C0532B"),
            homebutton = FALSE,
            layer.name = "NWIS Stream Gages & watersheds") +

mapview(koppen_park,
        zcol = 'label',
        col.regions = unique(koppen_park$color),
        alpha = 0,
        homebutton = FALSE,
        layer.name = "Koppen")
  #mapview(koppen_cent,
  #        layer.name = "Centroids")

color_list = c("#882314", "#C0532B", "#CF932C", "#674D53", "#8C86A0", "#724438",
               "#D5AB85","#01353D", "#088096", "#58B3C7", "#7AD4E4", "#B8FCFC",
               "#293633", "#3D5051", "#6B7F7F", "#87A1C7", "#516B95", "#304F7D",
               "#0067A2", "#DFCB91", "#CB7223", "#289A84", "#7FA4C2", "#AF7E56")

```
