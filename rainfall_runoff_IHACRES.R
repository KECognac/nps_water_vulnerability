#' This script explores runoff routing using functions described in IHACRES and
#' related models.

################################################################################
source("setup.R")
# IHACRES functions

# Add to source eventually
require("zoo")
require("akima")

################################################################################
#' Import and reformat daily data.RDS
#' Note, generated using Rainfall_runoff_data_prep.R
#' 
#' data.RDS is a Dataframe with cols:
#'        - date, runoff, accumswe, rain, PET,  and melt from WBM 
#'        - effR (rain + negative changes in accumswe (i.e., in theory melt))
#'        - `XX8_digit_integer` discharge in cfs from NWIS gage
#'        - discharge_in_d converted to inches per day

dir <- "data/park/BRCA/Rainfall_runoff_modeling/"
#sevier <- readRDS(paste0(dir,"east_fork_sevier_daily_wbm_discharge.RDS")
mammoth <- readRDS(paste0(dir,"mammoth_creek_daily_wbm_discharge.RDS"))


# Convert data.frame to timeseries object using zoo package
dat <- mammoth %>% 
  dplyr::select(date, P = runoff, Q = discharge_in_d, E = PET) %>%
  zoo::read.zoo(., format = "%Y-%m-%d") %>%
  zoo::as.zooreg()
# Also create monthly version
dat_monthly <- dat %>%
  stats::aggregate(., as.yearmon, sum, na.rm = TRUE) 

#' Subset data into calibration periods and test periods
cal_data <- window(dat_monthly, start = "1980-01-01", end = "1990-12-31")
test_data <- window(dat_monthly, start = "2011-01-01", end = "2023-12-31")


################################################################################
# Define some objective functions for parameter fitting

# sum of squared errors (SSE)
SSE <- function(estimated, observed) {
  sum((estimated - observed)^2,
      na.rm=TRUE)
}

# RMSE
RMSE <- function(estimated, observed) {
  squared_diff <- (estimated - observed)^2
  return(sqrt(mean(squared_diff)))
}

MAE <- function(estimated,observed) {
  mean(abs(estimated - observed))
}


NSE_R2 <- function(estimated,observed) {
#r.squared R Squared (Nash-Sutcliffe Efficiency), 
# 1−∑(Q-X)^2/∑(Q-Q_mean)^2
# better for R2
  ref <- mean(observed)
  err <- abs(observed - estimated)^2
  referr <- abs(observed - ref)^2
  1 - sum(err)/sum(referr)
}


BIAS <- function(estimated, observed) {
# good for matching mass balance -- however,
# in this case, MAE is better because error is + and -
  mean(estimated - observed)
}


R2_LOG <- function(estimated,observed) {
# R2 with log transform of data + offset where
# offset is Xth percentile of data - here 0.1 or 0.01
  offset <- quantile(observed,.01)
  log_observed <- log(observed + offset)
  log_estimated <- log(estimated + offset)
  lm_fit <- lm(log_observed ~ log_estimated)
  r_squared <- summary(lm_fit)$r.squared
  return(r_squared)
}


################################################################################
# Run optimization

# Some optimization references
#https://www.openanalytics.eu/blog/2022/05/17/new-nonlinear-ls-solvers-in-r/

#' method 1: 
#' stats::optim - General-purpose optimization based on Nelder–Mead, 
#' quasi-Newton and conjugate-gradient algorithms. It includes an option for 
#' box-constrained optimization and simulated annealing.

# set bounds for parameter estimation based on whether data are monthly
# or daily

if (attributes(cal_data)$frequency == 12) {
  # monthly data
  lower_bounds <- c(0.01,  5, 0.01, 0.01, 0.1)
       initial <- c( 0.1,  8,  0.5, 2,    0.5)
  upper_bounds <- c(   3, 12,    1, 5,      .8)
} else if (attributes(cal_data)$frequency == 1) {
  # daily data
  #                tau_q, tau_s, vs, delay, loss
  lower_bounds <- c(0.1,  50, 0.01,  1, 0.01)
       initial <- c(  3,  90,  0.5, 24,  0.5)
  upper_bounds <- c( 30, 120,    1, 50,    1)
}


# tau_q, tau_s, vs, delay, loss
optim_par <- optim(fn = fit_fun,
           method = 'L-BFGS-B',
           par = initial, 
           lower = lower_bounds, # monthly
           upper = upper_bounds, #monthly
           control = c("trace" = 6, "factr" = 1),
           obj = "NSE_R2")# function
# Plot results
print(optim_par$par)
ggarrange(fit_fun(params = optim_par$par, plot = TRUE, return_dat = FALSE),
          fit_fun(params = optim_par$par, plot = TRUE, return_dat = FALSE, 
                  dat = "test_data"), nrow = 2)


#' Method 2:
#' stats::nlminb - Unconstrained and box-constrained optimization using PORT 
#' routines.
nlminb_par <- nlminb(start = initial, 
            fit_fun,
            lower = lower_bounds,
            upper = upper_bounds,
            control = list("trace" = 6, "iter.max" = 200))

print(nlminb_par$par)
ggarrange(fit_fun(params = nlminb_par$par, plot = TRUE, return_dat = FALSE),
          fit_fun(params = nlminb_par$par, plot = TRUE, return_dat = FALSE, 
                  dat = "test_data"), nrow = 2)

#' Method 3: 
#' Manual
manual_par <- c(30,100,.4,15,.4) # daily
#         tau_q, tau_s, vs, delay, loss_fraction
manual_par <- c(.5, 7, .4, 1, .5) # monthly
#Q_mod <- fit_fun(params = manual_par, plot = TRUE, return_dat = TRUE)
ggarrange(fit_fun(params = manual_par, plot = TRUE, return_dat = FALSE),
          fit_fun(params = manual_par, plot = TRUE, return_dat = FALSE, 
                  dat = "test_data"), nrow = 2)

################################################################################
# Exploring results


# Example plotting outside of fit_fun

autoplot(cbind(cal_data$Q,Q_mod$Q_mod),
         facet=FALSE,
         ylab = "Discharge (in/d)",xlab="year") +
  scale_color_manual("",
                     values = c("dodgerblue","black"),
                     labels = c("observed", "modeled"))


# Looking at recharge with calibrated model
# set which pars to use (optim_par, nlminb_par, manual_par)
params <- optim_par$par
mod_out <- ihacres_routing_gw(U = cal_data$P, 
                   tau_q = params[1], 
                   tau_s = params[2], 
                   vs = params[3], 
                   delay = 0,#as.integer(params[4]), 
                   loss = .5,#params[5],
                   return_components = TRUE)

autoplot(cbind(cal_data$Q, mod_out$Q_mod, mod_out$Xg), facet = FALSE) +
  scale_color_manual("",values = c("black","dodgerblue","hotpink"))


# Q-Q plot of residuals
# this doesn't look great... should be a linear line if the residuals are evenly
# distributed.. need to work through different objective functions to consider
# how each one biases results. 
qqnorm(mod_out$Q_mod - cal_data$Q)


# Test conservation of mass
autoplot(cbind(cal_data$P %>% cumsum(),
               mod_out$Q_mod + mod_out$Xg %>% cumsum()), facets = FALSE)


################################################################################
# Visualize objective over parameter space
# set par values / ranges
tau_q <-seq(lower_bounds[1],upper_bounds[1],by=1)
tau_s <- seq(lower_bounds[2],upper_bounds[2],by=1)
vs <- seq(lower_bounds[3],upper_bounds[3],by=.1)
delay <- 1 #seq(1,50, by = )       # not used currently
loss <- .4 #seq(0,10,by = 2)
#tau_g <-  .1#seq(0,1, by = .1)
#R <- 1#seq(0,20, by = .5)

all_vars <- expand.grid(tau_q = tau_q, 
                        tau_s = tau_s, 
                        vs = vs,
                        delay = delay,
                        loss = loss)

if (nrow(all_vars) <= 500) { 
      all_vars_samp <- all_vars
} else {
      all_vars_samp <- all_vars[ sample(1:nrow(all_vars), 500,replace = FALSE), ]
}
rownames(all_vars_samp) <- NULL


er_all_vars <- apply(all_vars_samp, 1,
                     function(x) fit_fun(params = c(x[1],x[2],x[3],x[4], x[5]),
                                         return_dat = FALSE,
                                         obj = "all")) %>%
                      t() %>% data.frame() %>%
                    bind_cols(all_vars_samp,.) 


plot_er <- function(dataframe, x_col,y_col,z_col) {
  
  x_in <- dataframe[[x_col]]
  y_in <- dataframe[[y_col]]
  z_in <- dataframe[[z_col]]
  
  # Create a regular grid
  n <- 200
  x_grid <- seq(min(x_in), max(x_in), length = n)
  y_grid <- seq(min(y_in), max(y_in), length = n)
  
  # Interpolate z values onto the grid
  Z <- akima::interp(x_in, y_in, z_in, xo = x_grid, yo = y_grid,
                   linear = TRUE, extrap = FALSE)
  
  # Convert to dataframe
  grid_data <- as.data.frame(interp2xyz(Z)) 
  
  # Plot
  ggplot(grid_data, aes(x = x, y = y, z = z)) + 
  geom_raster(aes(fill = z)) +
       geom_contour(color = "white", bins = 20) +
    labs(x = x_col, 
         y = y_col, 
         z = z_col) +
    theme_classic() +
    guides(fill = guide_colorbar(title = z_col))
}

# View objective for select vars and objective
plot_er(er_all_vars, "tau_q","tau_s","SSE")

plots <- lapply(colnames(er_all_vars[,6:ncol(er_all_vars)]), 
                function(x) plot_er(er_all_vars,"tau_q","tau_s",x))

plot_all <- do.call(grid.arrange,plots)

