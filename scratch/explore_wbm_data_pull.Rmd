---
title: "Explore WBM Data Pull"
author: "Caitlin Mothes, PhD"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

source("setup.R")

# load in report data to get BRCA supply and boundary to test pulling
load("data/park/BRCA/BRCA_report_data.RData")

# get singl water supply point to test with
test_point <- POD_supply[1,]

# need to increase timeout option for downloading large daily files
options(timeout=10000)
```


## Explore Pulling Future WBM (edits to `getFutureWBM.R`)


### Create new function to pull future WBM data
```{r}
get_future_wbm <- function(park, aoi, years, macas, wb_var, path = "data/park/") {
  

  # check that path to save files to exists
  if (!dir.exists(paste0(getwd(), "/", path, "/", park, "/wbm_daily_rasters/"))) {
    dir.create(file.path(paste0(getwd(), "/", path, "/", park, "/wbm_daily_rasters/")), showWarnings = FALSE)
  }
  
  # create df of all variable, year, scenario combinations
  map_dat <- tidyr::crossing(years, wb_var, macas) %>%
    tidyr::separate_wider_delim(macas, delim = ".", names = c("maca", "rcp"))
  
  
  # transform aoi to crs of WBM data
  aoi <- st_transform(aoi, crs = "+proj=lcc +lat_0=42.5 +lon_0=-100 +lat_1=25 +lat_2=60 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs")
  
  # download each raster file to temp directory
  
  ## test using furrr
  # plan
  #plan(multisession, workers = parallelly::availableCores() - 1)
  
  rasters <- future_map(1:nrow(map_dat), function(x) {
    call <- paste0(
      "/vsicurl/",
      "http://www.yellowstone.solutions/thredds/fileServer/daily_or_monthly/gcm/",
      map_dat$rcp[x],
      "/",
      map_dat$maca[x],
      "/V_1_5_",
      map_dat$years[x],
      "_",
      map_dat$maca[x],
      "_",
      map_dat$rcp[x],
      "_",
      map_dat$wb_var[x],
      ".nc4"
    )
    
    r <- terra::rast(call)
    
    #  ## saved CRS and extent from raw downloaded file, that info does not attached to files pulled directly from URL
    # crs(r) <- "+proj=lcc +lat_0=42.5 +lon_0=-100 +lat_1=25 +lat_2=60 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"
    # 
    # ext(r) <- c(-2060750, 2639250, -1915500, 1384500)
    # 
    # # crop to aoi
    # r <- terra::crop(r, aoi)
    
    # assign informative names to each raster
    names(r) <- paste(map_dat$maca[x], map_dat$years[x], names(r), sep = "_")
  
    return(r)
    
  })
  
  ## combine all to single stack
  final_stack <- terra::rast(rasters)
  
  crs(final_stack) <- "+proj=lcc +lat_0=42.5 +lon_0=-100 +lat_1=25 +lat_2=60 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"
  
  ext(final_stack) <- c(-2060750, 2639250, -1915500, 1384500)
  
  # crop to aoi
  final_stack <- terra::crop(final_stack, aoi)
  
  return(final_stack)
  # save final raster stack to file
  # terra::writeRaster(
  #   final_stack,
  #   filename = paste0(
  #     getwd(),
  #     "/",
  #     path,
  #     "/",
  #     park,
  #     "/wbm_daily_rasters/",
  #     park,
  #     "_",
  #     wb_var,
  #     "_selected_cfs_",
  #     years[1],
  #     "_",
  #     years[length(years)],
  #     ".tif"
  #   ),
  #   overwrite = TRUE
  # )
  
}
```


### Test function

Use `profvis` to check for any bottle necks
```{r}
library(profvis)

start <- Sys.time()

profvis({get_future_wbm(
  park = park,
  aoi = st_buffer(park_boundary, 20000),
  years = 2023,
  wb_var = "runoff",
  macas = select_cfs$GCM
)
})

end <- Sys.time()

end - start


```

Read in the raster output to make sure it looks right
```{r}
daily_runoff <- rast("data/park/BRCA/wbm_daily_rasters/BRCA_runoff_selected_cfs_2023_2070.tif")
```


# Run function for full park data
Testing out adding `future_map()` to the function cut it down by 1 minute.

```{r}
plan(multisession, workers = parallelly::availableCores() - 1)

start <- Sys.time()

#walk(
test <- future_map(
  c(#"soil_water",
    "runoff"),
    #"rain",
    #"accumswe",
    #"PET",
    #"Deficit",
    #"AET"),
    ~ get_future_wbm(
      park = park,
      aoi = st_buffer(park_boundary, 20000),
      years = 2023:2070,
      wb_var = .x,
      macas = select_cfs$GCM
    )
  )

  
end <- Sys.time()

end - start
```

# Parallelize it with `furrr`


```{r}
library(furrr)
library(tictoc)

# plan
plan(multisession, workers = parallelly::availableCores() - 1)

tic()

future_walk(
      c(
        #"soil_water",
        "runoff",
        "rain"
        #"accumswe",
        #"PET",
        #"Deficit",
        #"AET"
      ),
      ~ get_wbm_grids(
        park = park,
        aoi_name = "test_furrr_2",
        aoi = watersupply_watershed,
        wb_var = .x,
        macas = select_cfs$GCM,
        path = path
      )
    )

toc()

# sets processing back to default
plan(sequential)

```

