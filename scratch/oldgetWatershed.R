#' Import NHD data for park
#' 
#' This function uses the nhdplusTools package to import flowline, catchments and
#' water body spatial data for parks, within a specified buffer distance around
#' the park boundary
#' 
#' @param aoi An sf polygon object, often a park boundary (or boundaries) retrieved from `getParkBoundary()`.
#' @param save Whether to save (TRUE) the resulting shapefile or not (FALSE)
#' @param path If `save = TRUE`, the file path to save the shapefiles to.
#' 
#' @return A list of spatial sf objects, one for flowlines, cactchments and water bodies
#' 
#' @seealso [getParkBoundary()]
getWatersheds <- function(aoi, save = FALSE, path){
  
  sf::sf_use_s2(FALSE)
  
  aois <- aoi
  
  park_names <- aois$UNIT_CODE[2]
  
  # read in the complete NHD (in tabular form) to make for much more efficient nhd crawling. 
  # This data in tabular form doesn't exist anywhere online that I know of... -_-
  nhd <- read_csv('data/all/nhd_flow_network.csv') 
  
  multiple <- function(park_names){
    
    #dir.create(file.path(paste0(getwd(),"/data/all/ws_trace/",park_names,"/")), showWarnings = FALSE)
    #dir.create(file.path(paste0(getwd(),"/data/all/ws_trace/",park_names,"/")), showWarnings = FALSE)
    
    
    aoi <- filter(aois, UNIT_CODE==park_names)
    
    # download flowlines for entire aoi
    nhd_flowlines <- nhdplusTools::get_nhdplus(AOI = aoi, 
                                               realization='flowline')
    
    # add `tocomid` field to ID flowlines that cross over the aoi
    # this step massively speeds up run time by reducing the number
    # of watersheds that need to be created
    park_flowlines <- nhd_flowlines  %>%
      dplyr::select(-id) %>%
      dplyr::distinct(comid, .keep_all=TRUE) %>%
      nhdplusTools::get_tocomid(., add=TRUE)
    
    # minimize number of origin points by selecting only those that cross park boundary
    outsiders <- park_flowlines %>%
      filter(tocomid==0) %>%
      tibble::rowid_to_column(., "index")
    
    # FUNCTION THAT, FOR EVERY POUR POINT, IDENTIFIES ALL UPSTREAM AND DOWNSTREAM FLOWLINES
    watersheds <- function(spid_union){
      
      tracer <- function(samples){
        outsiders <- as_tibble(outsiders)
        outlet <- outsiders %>%
          dplyr::filter(index == samples)
        upstream <- nhdplusTools::get_UT(nhd, outlet$comid) %>% #upstream trace function in nhdplusTools
          tibble::as_tibble() %>%
          dplyr::rename(comid_list = value) 
        # downstream <- nhdplusTools::get_DM(nhd, outlet$comid) %>% #downstream trace function in nhdplusTools
        #   tibble::as_tibble() %>%
        #   dplyr::rename(comid_list = value)
        # rbind(upstream,downstream) %>%
        distinct(upstream, comid_list, .keep_all = TRUE) %>%
          dplyr::filter(comid_list != outlet$comid) #%>%
        #write_csv(paste0('data/all/ws_trace/', park_names, '/', outlet$comid, '.csv'))
      }
      ws <- map_dfr(spid_union, tracer)
    }
    
    park_ws <- outsiders %>%
      dplyr::mutate(comid_list = map(index, watersheds)) %>%
      unnest(cols = comid_list) %>%
      distinct(comid_list) %>%
      sf::st_drop_geometry() %>%
      rename(comid = comid_list)
    
    # Save intermediary steps for workflow formation
    # park_ws <- list.files(path = paste0('data/all/ws_trace/', park_names, '/'), pattern = paste0("*.csv"), full.names = TRUE) %>%
    #   plyr::ldply(., .fun = read_csv) %>%
    #   distinct(comid_list) %>%
    #   rename(comid=comid_list)
    
    # if the previous pour points didn't capture all flowlines within the park, 
    # get traces of flowlines within the park boundary: 
    # (this hasn't happened yet... but who knows if it might)
    # might screw up newer downstream code
    
    # if(nrow(park_flowlines %>% filter(!comid %in% park_ws$comid)) != 0){
    #   
    #   outsiders <- park_flowlines %>%
    #     filter(!comid %in% park_ws$comid_list) %>%
    #     tibble::rowid_to_column(., "index")
    #   
    #   new_park_ws <- outsiders %>%
    #     dplyr::mutate(comid_list = map(index, watersheds))
    #   
    #   park_ws <- list.files(path = "data/all/temp/", pattern = "*.csv", full.names = TRUE) %>%
    #     plyr::ldply(., .fun = read_csv) %>%
    #     distinct(comid_list)
    # }
    # 
    # get flowlines
    
    splitter_flowlines <- nhdplusTools::get_nhdplus(comid = outsiders$comid,
                                                    realization='flowline',
                                                    t_srs = 4269) %>%
      select(comid)
    
    nhd_flowlines <- nhdplusTools::get_nhdplus(comid = park_ws$comid,
                                               realization='flowline',
                                               t_srs = 4269) %>%
      dplyr::select(comid) %>%
      bind_rows(splitter_flowlines) %>%
      distinct(comid,.keep_all=TRUE)
    
    grouper <- igraph::components(igraph::graph.adjlist(sf::st_touches(nhd_flowlines)))[[1]] %>%
      as_tibble() %>%
      rename(relationship=value)
    
    grouped_flowlines <- cbind(nhd_flowlines,grouper) %>% 
      group_by(relationship) %>%
      summarize()
    
    # include catchments in the park that are not contained in trace (no NHD flowlines associated with them)
    
    nhd_empty_catchments <- nhdplusTools::get_nhdplus(AOI = aoi, 
                                                      realization='catchment') %>%
      distinct(featureid, .keep_all=TRUE) %>%
      filter(!featureid %in% nhd_flowlines$comid) %>%
      filter(!featureid %in% outsiders$comid) %>%
      mutate(relationship=0) %>%
      select(relationship) %>%
      sf::st_intersection(.,aoi)
    
    splitters <- nhdplusTools::get_nhdplus(comid = outsiders$comid,
                                           realization='catchment',
                                           t_srs = 4269) %>%
      sf::st_intersection(.,aoi)
    
    # splitters_flowlines <- nhdplusTools::get_nhdplus(comid = outsiders$comid,
    #                                                  realization='flowline',
    #                                                  t_srs = 4269) %>%
    #   sf::st_intersection(.,aoi)
    
    # get catchments 
    grouped_catchments <- nhdplusTools::get_nhdplus(comid = park_ws$comid,
                                                    realization='catchment',
                                                    t_srs = 4269) %>%
      filter(!featureid %in% outsiders$comid) %>%
      bind_rows(splitters) %>%
      sf::st_join(.,grouped_flowlines) %>%
      group_by(relationship) %>%
      summarize() %>%
      bind_rows(nhd_empty_catchments) %>%
      summarize() %>%
      nngeo::st_remove_holes() %>%
      sf::st_join(aoi) #%>%
    #sf::st_write(paste0('data/all/watersheds/',aoi$UNIT_CODE,'_group_watersheds.shp'), append=FALSE, delete_layer=TRUE)
    #test <- readRDS('data/all/MOJA_group_watersheds.shp')
    #mapview::mapview(test) + mapview(aoi)
    # nhd_flowlines <- nhd_flowlines %>%
    #   filter(!comid %in% outsiders$comid) %>%
    #   bind_rows(splitters_flowlines) %>%
    #   sf::st_join(dplyr::select(grouped_catchments,UNIT_CODE)) %>%
    #   sf::st_write(paste0('data/all/',aoi$UNIT_CODE,'_flowlines.shp'))
    print(paste0(park_names, " watershed delineated!"))
  }
  
  map(park_names,multiple)
  # SOME PARKS ARE POLYGONS, OTHERS ARE MULTIPOLYGONS
  obj <- list.files(path = "data/all/watersheds/", pattern =  "*.shp", full.names = TRUE) %>%
    plyr::ldply(., .fun = st_read) %>%
    filter(UNIT_CODE %in% park_names)
  
  return(obj)
}