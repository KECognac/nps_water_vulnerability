#' Create watershed boundary shapfile(s) for an area of interest.
#' 
#' This function uses the nhdplusTools package to import flowline, catchments and
#' water body spatial data for parks, within a specified buffer distance around
#' the park boundary
#' 
#' @param aoi An sf polygon object, often a park boundary (or boundaries) retrieved from `getParkBoundary()`.
#' @param save Whether to save (TRUE) the resulting shapefile(s) or not (FALSE)
#' @param path If `save = TRUE`, the file path to save the shapefile(s) to.
#' @param clipped Whether to clip watersheds at AOI boundary (TRUE) or return unclipped (full extent of) watersheds that intersect with AOI (FALSE) 
#' 
#' @return Watershed shapefile(s) for the aoi
#' 
#' @seealso [getParkBoundary()]
getWatersheds <- function(aoi, save = TRUE, clipped = TRUE, path = "data/all/"){
  
  sf::sf_use_s2(FALSE)
  
  aois <- aoi
  
  park_names <- aois$UNIT_CODE
  
  # read in the complete NHD (in tabular form) to make for much more efficient nhd crawling. 
  # This data in tabular form doesn't exist anywhere online that I know of... -_-
  nhd <- readr::read_csv('data/all/nhd_flow_network.csv') 
  
  #dir.create(file.path(paste0(getwd(),"/data/all/ws_trace/",park_names,"/")), showWarnings = FALSE)
  #dir.create(file.path(paste0(getwd(),"/", path, "/", park_names,"/")), showWarnings = FALSE)
  
  aoi <- dplyr::filter(aois, UNIT_CODE == park_names)
  
  # download flowlines for entire aoi
  nhd_flowlines <- nhdplusTools::get_nhdplus(AOI = aoi, 
                                             realization='flowline')
  
  # add `tocomid` field to ID flowlines that cross over the aoi
  # this step massively speeds up run time by reducing the number
  # of watersheds that need to be created
  park_flowlines <- nhd_flowlines  %>%
    #dplyr::select(-id) %>%
    dplyr::distinct(comid, .keep_all=TRUE) %>%
    nhdplusTools::get_tocomid(., add=TRUE)
  
  # minimize number of origin points by selecting only those that cross AOI boundary
  outsiders <- park_flowlines %>%
    dplyr::filter(tocomid==0) %>%
    tibble::rowid_to_column(., "index")
  
  # FUNCTION THAT, FOR EVERY "OUTSIDER" POUR POINT, IDENTIFIES ALL UPSTREAM FLOWLINES
  watersheds <- function(spid_union){
    
    tracer <- function(samples){
      outsiders <- as_tibble(outsiders)
      outlet <- outsiders %>%
        dplyr::filter(index == samples)
      upstream <- nhdplusTools::get_UT(nhd, outlet$comid) %>% #upstream trace function in nhdplusTools
        tibble::as_tibble() %>%
        dplyr::rename(comid_list = value) %>%
        dplyr::distinct(comid_list, .keep_all = TRUE) %>%
        dplyr::filter(comid_list != outlet$comid) 
    }
    
    ws <- purrr::map(spid_union, tracer) %>% dplyr::bind_rows()
    
  }
  
  park_ws <- outsiders %>%
    dplyr::mutate(comid_list = map(index, watersheds)) %>%
    tidyr::unnest(cols = comid_list) %>%
    dplyr::distinct(comid_list) %>%
    sf::st_drop_geometry() %>%
    dplyr::rename(comid = comid_list)
  
  splitter_flowlines <- nhdplusTools::get_nhdplus(comid = outsiders$comid,
                                                  realization='flowline',
                                                  t_srs = 4269) %>%
    dplyr::select(comid)
  
  nhd_flowlines <-  park_ws$comid %>%
    purrr::map(~nhdplusTools::get_nhdplus(comid = .,
                                   realization='flowline',
                                   t_srs = 4269) %>% dplyr::select(comid)) %>%
    dplyr::bind_rows() %>%
    #dplyr::select(comid) %>%
    dplyr::bind_rows(splitter_flowlines) %>%
    dplyr::distinct(comid,.keep_all=TRUE)
  
  
  grouper <- igraph::components(igraph::graph.adjlist(sf::st_touches(nhd_flowlines)))[[1]] %>%
    tibble::as_tibble() %>%
    dplyr::rename(relationship = value)
  
  grouped_flowlines <- dplyr::bind_cols(nhd_flowlines, grouper) %>% 
    dplyr::group_by(relationship) %>%
    dplyr::summarize()
  
  # include catchments in the park that are not contained in trace (no NHD flowlines associated with them)
  nhd_empty_catchments <- nhdplusTools::get_nhdplus(AOI = aoi, 
                                                    realization='catchment') %>%
    dplyr::distinct(featureid, .keep_all=TRUE) %>%
    dplyr::filter(!featureid %in% nhd_flowlines$comid) %>%
    dplyr::filter(!featureid %in% outsiders$comid) %>%
    dplyr::mutate(relationship = 0) %>%
    dplyr::select(relationship)
    
  
  
  splitters <- nhdplusTools::get_nhdplus(comid = outsiders$comid,
                                         realization = 'catchment',
                                         t_srs = 4269) 
  if (clipped == TRUE) {
    splitters %>%
      sf::st_intersection(.,aoi) 
    nhd_empty_catchments %>%
      sf::st_intersection(.,aoi)
  }
  
  grouped_catchments <- park_ws$comid %>%
    purrr::map(~nhdplusTools::get_nhdplus(comid = .,
                                   realization = 'catchment',
                                   t_srs = 4269)) %>%
    dplyr::bind_rows() %>%
    dplyr::filter(!featureid %in% outsiders$comid) %>%
    dplyr::bind_rows(splitters) %>%
    sf::st_join(.,grouped_flowlines) %>%
    dplyr::bind_rows(nhd_empty_catchments) %>%
    dplyr::group_by(relationship) %>%
    dplyr::summarize() %>%
    nngeo::st_remove_holes() %>%
    sf::st_join(aoi) %>%
    dplyr::select(-relationship)
  
  if(save == TRUE){
    sf::st_write(grouped_catchments, paste0(getwd(),"/", path, "/", park_names, "_watersheds.shp"), 
             append = FALSE)
  }
  
  print(paste0(park_names, " watershed delineated!"))
  
  return(grouped_catchments)
  
}