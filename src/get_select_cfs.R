#' Divergent climate models were selected for the park and koppen centroids. 
#' This function selects which to use based on either the shortest distance
#' between the centroid and watersupply watershed (method = "distance") or 
#' the koppen centroid that matches the watersupply watershed (method = "koppen") 
#' 
#' @param park_boundary
#' @param watersupply_watershed
#' @param method
#' 
#' @returns select_cfs dataframe containing the selected climate futures for
#' the selected centroid.
#' 
get_select_cfs <- function(park_boundary, watersupply_watershed, method) {
  
  # Get koppen climate grid for the park
  koppen_park <- get_koppen(aoi = park_boundary, 
                            buffer_dist = 0.1)
  
  
  # Determine which Koppen climate intersects the watersupply watershed. 
  ws_union <- sf::st_union(watersupply_watershed) %>%
    sf::st_as_sf()
  
  koppen_ws <- get_koppen(aoi = ws_union, 
                          buffer_dist = 0) %>%
    sf::st_transform(., crs = sf::st_crs(ws_union)) %>%
    dplyr::filter(st_intersects(., ws_union) %>% 
                    as.logical())
  
  
  # Create a table of Koppen and park centroids with area span for each koppen
  # climate that overlaps with watersupply watershed (from above) and distance
  # between centroid location and watersupply watershed. 
  
  #****KEC:  Note, nothing is done with this as of now, but we can incorporate 
  #* later
  
  centroid_sel <- 
    # get table of koppen centroids from web
    GET('https://parkfutures.s3.us-west-2.amazonaws.com/maca-tprh-data/0Climate_Zones_by_Unit_cleaned.csv') %>% 
    as.character() %>% 
    data.table::fread(.,header = TRUE, skip = 1) %>%
    dplyr::filter(UNIT_CODE == park) %>%
    sf::st_as_sf(coords = c("Lon","Lat"), 
                 crs = sf::st_crs(watersupply_watershed)) %>%
    # Calc. distance between centroid and watersupply watershed
    dplyr::mutate(dist = (sf::st_distance(geometry,ws_union))) %>%
    # Add park centroid point
    bind_rows(sf::st_centroid(park_boundary) %>% 
                st_as_sf() %>%
                dplyr::mutate(dist = (sf::st_distance(Shape, ws_union)))) %>%
    sf::st_set_geometry(., NULL) %>%
    # Clean some metadata / cols
    dplyr::select(c(ClimateZone,dist)) %>%
    dplyr::mutate(CZ_str = sprintf("_%02d", ClimateZone),
                  CZ_str = str_replace(CZ_str, "_NA", ""),
                  centroid = paste0(park,CZ_str)) %>%
    dplyr::left_join(koppen_ws %>% dplyr::count(K_vals), 
                     by = c("ClimateZone" ="K_vals")) %>%
    dplyr::select(-CZ_str)
  
  # Pull centroid with minimum distance to watersupply watershed
  min_dist_cent <- centroid_sel[which.max(centroid_sel$n),]$centroid
  
  # Pull centroid corresponding to maximum overlap with watersupply watershed
  max_overlap_cent <- centroid_sel[which.max(centroid_sel$n),]$centroid
  
  # Import table of selected futures for site. Selections were made using the "select_GCMs" 
  # function. 
  select_cfs <- data.table::fread('data/parkwide_gcms_wbm_filtered.csv') %>% 
    mutate_at("centroid", str_replace, "_future", "") %>%
    dplyr::filter(park %in% {{park}},
                  CF %in% c("Warm Wet", "Hot Dry"))
  
  if(method == "distance") {
    
    select_cfs <- select_cfs %>%
    dplyr::filter(centroid == min_dist_cent)
    
  } else if (method == "koppen") {
    
    select_cfs <- select_cfs %>%
      dplyr::filter(centroid == max_overlap_cent)
  }
 
  return(select_cfs) 
 
}
