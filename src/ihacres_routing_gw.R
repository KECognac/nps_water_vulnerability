#' IHACRES routing function with added groundwater component.  This function 
#' takes in a timeseries of effective rainfall or lumped runoff (U) and uses a 
#' recursive filter to partition U into slowflow (Xs) and quickflow (Xq). A 
#' fraction of Xs can be routed as groundwater recharge (loss).  Recharge will
#' then be proportional to Xs, which is presumed to be the case in settings
#' where stream seepage is a predominant groundwater recharge mechanism and
#' streamflow is highly seasonal and sourced from snowmelt and individual
#' precipitation events.
#' 
#' 
#' This function is based on the expuh function in Hydromad with an addition of
#' the GW loss term. 
#' 
#' Andrews F, Guillaume J, Vervoort W, Buzacott A (2021). hydromad: Hydrological 
#' Model Assessment and Development. http://hydromad.catchment.org/, 
#' https://github.com/josephguillaume/hydromad.
#'       
#' @param U timeseries of effective runoff (zoo object of regular frequency)
#' @param tau_q Recession coefficient for quickflow (time unit of U)
#' @param tau_s Recession coefficient for slowflow (time unit of U)
#' @param vs Fraction of effective rainfall that goes to slowflow (-)
#' @param loss Fraction of slow flow that goes to groundwater recharge (-)
#' 
ihacres_routing_gw <- function(U, tau_q, tau_s, vs, delay,loss,
                               return_components = FALSE) {
  
  #U <- cal_data$P
  #tau_q <- 5
  #tau_s <- 50
  #vs<- .8
  #delay <- 1
  #loss <- .5
  
  attrs <- attributes(U)
  
  na.action <- na.pass
  U <- na.action(U)
  
  stopifnot(all(c(tau_s, tau_q) >= 0))
  
  vq <- 1-vs
  
  alpha_s <- exp(-1/tau_s)
  alpha_q <- exp(-1/tau_q)
  
  beta_s <- vs*(1-alpha_s)
  beta_q <- vq*(1-alpha_q)
  
  delay <- round(delay)
  
  if (delay != 0) {
    U <- stats::lag(U, -delay)
  }
  
  Xs_0 <- 0 
  Xq_0 <- 0
  
  Xs <- Xq <- Xg <- U * NA

  
  # Slow flow 
  Xs[] <- stats::filter(beta_s * U, 
                        alpha_s, 
                        method = "recursive", 
                        init = Xs_0) 
  # GW Loss
  Xg <- loss*Xs
  
  # Subtract loss from slow flow
  Xs <- Xs - Xg
  
  # Quick flow
  Xq[] <- stats::filter(beta_q * U, 
                          alpha_q, 
                          method = "recursive", 
                          init = Xq_0)
  

  #Xs <- stats::lag(Xs, delay)
  #Xq <- stats::lag(Xq, delay)
  #Xg <- stats::lag(Xq, delay)
  
  #attributes(Xs) <- attrs
  #attributes(Xq) <- attrs
  #attributes(Xg) <- attrs
  
  if (return_components == FALSE) {
  return(Xs + Xq)
  }
  else if (return_components == TRUE) {
    return(cbind(Xs,Xq,Xg,Q_mod = Xs+Xq))
  }

    
}
