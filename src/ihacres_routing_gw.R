#' IHACRES routing function with added groundwater component.
#' 
#' Applies a constant loss fraction to the slow flow term (Xs) that represents
#' groundwater recharge. 
#' 
#' This version was based on the expuh function in Hydromad
#' except for the implementation of the loss term.  Expuh calculates
#' GW loss differently using a method that was developed specifically for 
#' ephemeral streams.  This function is more basic but need to confirm 
#' This function borrows from the implementation of the expuh routing function 
#' in the Hydromad package except for the implementation of the loss term.  
#' Expuh calculates GW loss differently using a method that was developed 
#' specifically for ephemeral streams.  This function is more basic but need to 
#' confirm: 
#'    a. that mass balance is conserved
#'    b. that loss parameter isn't just duplicating the existing scaling of
#'       runoff through the recursive exponential decay function
#'    c. how the "gw" component compares to this vs the ihacres_routing
#'       function without gw loss. 
#'
#' Andrews F, Guillaume J, Vervoort W, Buzacott A (2021). hydromad: Hydrological 
#' Model Assessment and Development. http://hydromad.catchment.org/, 
#' https://github.com/josephguillaume/hydromad.
#'       
#' @param U timeseries of effective runoff
#' @param tau_q 
#' @param tau_s
#' @param vs
#' @param loss
#' 
ihacres_routing_gw <- function(U, tau_q, tau_s, vs, delay,loss,
                               return_components = FALSE) {
  
  #U <- cal_data$P
  #tau_q <- 5
  #tau_s <- 50
  #vs<- .8
  #delay <- 1
  #loss <- .5
  
  attrs <- attributes(U)
  
  na.action <- na.pass
  U <- na.action(U)
  
  stopifnot(all(c(tau_s, tau_q) >= 0))
  
  vq <- 1-vs
  
  alpha_s <- exp(-1/tau_s)
  alpha_q <- exp(-1/tau_q)
  #alpha_g <- exp(-1/tau_g)
  
  beta_s <- vs*(1-alpha_s)
  beta_q <- vq*(1-alpha_q)
  #beta_g <- vg*(1-alpha_g)
  
  #lossVal <- (1 - alpha_s) * loss
  
  delay <- round(delay)
  
  if (delay != 0) {
    U <- stats::lag(U, delay)
  }
  
  Xs_0 <- 0 
  Xq_0 <- 0
  #Xg_0 <- 0
  
  Xs <- Xq <- Xg <- U * NA

  
  # Slow flow 
  Xs[] <- stats::filter(beta_s * U, 
                        alpha_s, 
                        method = "recursive", 
                        init = Xs_0) 
  # GW Loss
  Xg <- loss*Xs
  
  # Subtract loss from slow flow
  Xs <- Xs - Xg
  
  # Quick flow
  Xq[] <- stats::filter(beta_q * U, 
                          alpha_q, 
                          method = "recursive", 
                          init = Xq_0)
  

  Xs <- stats::lag(Xs, delay)
  Xq <- stats::lag(Xq, delay)
  Xg <- stats::lag(Xq, delay)
  
  attributes(Xs) <- attrs
  attributes(Xq) <- attrs
  attributes(Xg) <- attrs
  
  if (return_components == FALSE) {
  return(Xs + Xq)
  }
  else if (return_components == TRUE) {
    return(cbind(Xs,Xq,Xg,Q_mod = Xs+Xq))
  }

  ## 
    
}
