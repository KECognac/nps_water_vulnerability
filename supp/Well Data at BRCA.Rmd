---
title: "Untitled"
author: "Katie Willi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      error = FALSE,
                      message = FALSE)

source("setup.R")
```

##### Watersheds of the park

```{r}
# get park boundary
park_boundary <- getParkBoundary(park="BRCA")

# pull in the park watersheds as a starting AOI for pulling in WBM data:
park_watershed <- getWatersheds(aoi = park_boundary, save = FALSE)# st_read('data/park/BRCA/park_watersheds.shp')
```

##### Watersheds of park water supplies

NPS water supply locations may not necessarily be within the park, and therefore their watersheds may not be represented in the park boundary's watersheds delineated above. So, here I am pulling in the water supply locations of interest, and delineating their own watersheds to ensure we capture them in the WBM pull. Water supply locations are found using the [Utah Division of Water Rights database](https://maps.waterrights.utah.gov/asp/wrplatGE.asp).

```{r}
# get Utah points of diversion near BRCA
POD_Utah <- getPODUtah(aoi = park_watershed, dist = 0.1)

# filter to water supplies of interest
POD_park <- POD_Utah %>%
  dplyr::filter(WRNUM %in% c("61-893", "2061001M00")) %>% #, current supply Well 1, Well 2
  # "61-1143")) %>% # potential future supply
  distinct(LOCATION, .keep_all = TRUE) %>%
  mutate(well = c("Well 3", "Well 1", "Well 2"))

watersupply_watershed <- vector("list", nrow(POD_park))

# get the watersheds of different points:
for(i in 1:nrow(POD_park)){
  
  watersupply_watershed[[i]] <- POD_park[i,] %>% 
    getXYWatersheds(sf = ., coordinates = NULL)
  
}

watersupply_watershed <- watersupply_watershed %>%
  bind_rows() %>% 
  distinct(featureid, .keep_all = TRUE) %>%
  #... hard to tell from topo what the future supply's real watershed looks like... 
  # But! This future supply is a deep (100 ft) well, so it may not be as important.
  # I'll need to look into this further at some point.
  filter(!featureid %in% c("10807991", "10807997"))
```

##### Well data

BRCA has been measuring static water levels at their water supply wells since at least 2000. In 1998ish, they performed a pump test that resulted in the following hydrogeologic characteristics:

-	Hydraulic conductivity ratio = 1:10
-	Transmissivity (T) = 8900 ft^2/day
-	Specific Yield (Sy) = 0.37
-	Kr = 150 feet/day
-	Aquifer thickness = 60 feet
-	Hydraulic gradient between well 1 and 2 = 0.0057 ft/ft
-	Hydraulic gradient upstream of well field = 0.0042 ft/ft
-	Average daily use = 112,000 gallons/day (or, 15,000 cubic feet/day) … summer pumpage … but greatly overestimates winter use.


```{r}
well_raw <- read_csv('data/park/BRCA/manual/BRCA_Well_Data.csv') 
names(well_raw) <- make.names(names(well_raw))

well_daily <- well_raw %>%
  dplyr::mutate(static_mm = 25.4 * as.numeric(str_replace(Static..in., "-", "")),
                date = ymd(...1),
                ym = ym(substr(date, 1, 7))) %>%
  dplyr::select(date,
                ym,
                well = Well,
                static_mm) %>%
  mutate(well = case_when(well == "Well # 1" ~ "Well 1",
                          well == "Well #2" ~ "Well 2")) %>%
  mutate(season = case_when(month(ym) %in% c(12,1,2) ~ "Winter",
                            month(ym) %in% c(3,4,5) ~ "Spring",
                            month(ym) %in% c(6,7,8) ~ "Summer",
                            month(ym) %in% c(9,10,11) ~ "Fall"))

# Find how much data is available during this time period for each site:
daily_well_timeline <- well_daily %>%
  group_by(well) %>%
  filter(!is.na(static_mm)) %>%
  summarize(min = min(date), #start date
            max = max(date), #end date
            # how many days exist between the start and end date
            possible_n = (as.numeric(ymd(max(date)) - ymd(min(date))) + 1),
            # how many days we have a record for:
            actual_n = n()) %>%
  mutate(completeness = 100 * (actual_n/possible_n))

# Find how much data is available during this time period for each site BY MONTH:
monthly_well_timeline <- well_daily %>%
  group_by(well, ym) %>%
  summarize(mean_static_mm = mean(static_mm, na.rm = TRUE)) %>%
  ungroup() %>%
  group_by(well) %>%
  summarize(min = min(ym),
            max = max(ym),
            possible_n = n(),
            # how many days we have a record for:
            actual_n = sum(!is.na(mean_static_mm))) %>%
  mutate(completeness = 100 * (actual_n/possible_n))

# Find how much data is available during this time period for each site BY WEEK:
weekly_well_timeline <- well_daily %>%
  mutate(week = week(date),
         year = year(date)) %>%
  group_by(well, week, year) %>%
  summarize(mean_static_mm = mean(static_mm, na.rm = TRUE)) %>%
  ungroup() %>%
  group_by(well) %>%
  summarize(min = min(year),
            max = max(year),
            possible_n = n(),
            # how many days we have a record for:
            actual_n = sum(!is.na(mean_static_mm))) %>%
  mutate(completeness = 100 * (actual_n/possible_n))
```

The state of Utah also tracks monthly water use of that system:

```{r}
water_supply <- getWaterSuppliersUtah(aoi = park_boundary) %>%
  filter(grepl("National Park", WRNAME, ignore.case=TRUE)) %>%
  .$WRID

water_use_1 <- getWaterUseUtah(WRID = water_supply)[[1]] %>%
  slice(1:39) %>%
  pivot_longer(-c("Year", "Method of Measurement"), names_to = "month", values_to = "use_acre_feet") %>%
  mutate(ym = ym(paste0(Year, "-", month))) %>%
  filter(month != "Annual inAcre Feet") %>%
  select(ym, use_acre_feet) %>%
  mutate(well = "Well 1")

water_use_2 <- getWaterUseUtah(WRID = water_supply)[[1]] %>%
  slice(51:nrow(.)) %>%
  dplyr::filter(!is.na(as.numeric(Year))) %>%
  pivot_longer(-c("Year", "Method of Measurement"), names_to = "month", values_to = "use_acre_feet") %>%
  mutate(ym = ym(paste0(Year, "-", month))) %>%
  filter(month != "Annual inAcre Feet") %>%
  select(ym, use_acre_feet) %>%
  mutate(well = "Well 2")

both_wells <- water_use_1 %>%
  bind_rows(water_use_2)
```

Here we combine the average monthly static water levels with the monthly water use:

```{r}
well_monthly <- well_daily %>%
  group_by(well, ym, season) %>%
  summarize(mean_static_mm = mean(static_mm, na.rm = TRUE)) %>%
  ungroup() %>%
  #mutate_all(~ifelse(is.nan(.), NA, .)) %>%
  mutate(mean_static_mm_filled = zoo::na.approx(mean_static_mm)) %>%
  mutate(mean_static_mm_filled_id = ifelse(is.na(mean_static_mm), mean_static_mm_filled, NA)) %>%
  left_join(both_wells, by = c("ym", "well")) %>%
  arrange(ym)

# ggplot(data = well_data) +
#   geom_point(aes(x = mean_static, y = use_acre_feet, color = well))
```

```{r}
ggplot() +
  geom_path(data = well_daily, aes(x = date, y = static_mm, color = well)) +
  facet_wrap(~well, nrow = 2) +
  theme_bw()

ggplot(data = well_monthly) +
  geom_point(aes(x = ym, y = mean_static_mm, color = well)) +
  geom_line(aes(x = ym, y = mean_static_mm_filled), color = "black") +
  #geom_smooth(aes(x = ym, y = mean_static_mm, color = well), method = "lm") +
  facet_wrap(~well, nrow = 2) +
  theme_bw()

ggplot(data = well_monthly) +
  geom_line(aes(x = ym, y = as.numeric(use_acre_feet), color = well)) +
  geom_smooth(aes(x = ym, y = as.numeric(use_acre_feet), color = well), method = "lm") +
  facet_wrap(~well, nrow = 2) +
  theme_bw()

tidier_sens <- function(data){
  
  model <- trend::sens.slope(data)
  
  broom::tidy(model) %>%
    mutate(slope = model$estimates)
  
}

well_mk <- well_monthly %>%
  group_by(well) %>%
  arrange(ym) %>%
  nest()  %>%
  mutate(tidy_mods = map(data, ~ tidier_sens(.x$mean_static_mm_filled))) %>%
  unnest(tidy_mods) 

```

Using the nearest WBM grid:

```{r}
supply_wbm_runoff <- list.files('data/misc/wbm_hist/', pattern = "*runoff", full.names = TRUE) %>%
  map_dfr(~read_csv(.)) %>%
  data.table::data.table() %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4269) %>%
  .[watersupply_watershed,] %>%
  filter(x == -1029250 & y == -441000) %>%
  mutate(date = as_date(time),
         ym = ym(substr(date, 1, 7))) %>%
  inner_join(well_monthly, by = "ym")

# Well level compared to runoff at nearest point:
ggplot(supply_wbm_runoff) +
  geom_point(aes(x = (mean_static_mm), y = val, color = season)) +
  facet_wrap(~well, nrow = 2)+
  theme_bw() +
  xlab("Mean Monthly Well Depth (mm)") +
  ylab("NPS WBM Runoff (mm)")

# Well level compared to runoff at nearest point, runoff == 0 removed
# The runof == 0 seems to occur more frequently than anything else... 
ggplot(data = filter(supply_wbm_runoff, val == 0)) +
  geom_histogram(aes(x = mean_static_mm, fill = as.factor(season))) + 
  theme_bw() +
  facet_wrap(~well, nrow = 2)

# no runoff > 0 during the summer
ggplot(data = filter(supply_wbm_runoff, val > 0)) +
  geom_histogram(aes(x = val, fill = as.factor(season))) + 
  theme_bw() +
  facet_wrap(~well, nrow = 2)
```

Using avg. of watershed:

```{r}
supply_wbm_runoff <- list.files('data/misc/wbm_hist/', pattern = "*runoff", full.names = TRUE) %>%
  map_dfr(~read_csv(.)) %>%
  data.table::data.table() %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4269) %>%
  .[watersupply_watershed,] %>%
  mutate(date = as_date(time),
         ym = ym(substr(date, 1, 7))) %>%
  group_by(ym) %>%
  summarize(mean_runoff = mean(val, na.rm = TRUE),
            total_runoff = sum(val, na.rm = TRUE)) %>%
  inner_join(well_monthly, by = "ym") 

# Well level compared to runoff at nearest point:
ggplot(supply_wbm_runoff) +
  geom_point(aes(x = mean_static_mm, y = mean_runoff, color = season)) +
  facet_wrap(~well, nrow = 2)+
  theme_bw() +
  xlab("Mean Monthly Well Depth (mm)") +
  ylab("NPS WBM Runoff (mm)")


# Well level compared to mean runoff across watershed, runoff == 0 removed
# The runof == 0 seems to occur more frequently when the well levels drop below 75. 
ggplot(data = filter(supply_wbm_runoff, mean_runoff > 0)) +
  geom_histogram(aes(x = mean_static_mm, fill = as.factor(season))) + 
  theme_bw() +
  facet_wrap(~well, nrow = 2)

ggplot()+
  geom_line(data = supply_wbm_runoff, aes(x = ym, y = mean_runoff)) +
  geom_point(data = filter(supply_wbm_runoff, mean_runoff > 0), aes(x=ym, y = mean_runoff), color = "red")
```

Precip vs. well data:

Download nearby NOAA data:
```{r}
# Find NOAA weather stations near our areas of interest
noaa_data <- getNOAA(aoi = st_buffer(park_boundary, 0.1), park = "misc") %>%
  #              prcp = Precipitation (tenths of mm)
  #    	         snow = Snowfall (mm)
  # 	           snwd = Snow depth (mm)
  #              tmax = Maximum temperature (tenths of degrees C)
  #              tmin = Minimum temperature (tenths of degrees C)
  #              elevation = meters
  select(name, id, date, tmax, tmin, prcp, snow, snwd, elevation, geometry) %>%
  # Raw NOAA data is in "tenths of" units for temp and precip:
  mutate_at(c("tmax", "tmin", "prcp"), function(x) {x * 0.10})

noaa_data_ym <- noaa_data %>%
  data.table::data.table() %>%
  mutate(ym = ym(substr(date, 1, 7))) %>%
  group_by(name, id, ym, geometry) %>%
  summarize(tmax = mean(tmax, na.rm = TRUE),
            tmin = mean(tmin, na.rm = TRUE),
            tmean = ((tmax+tmin)/2),
            prcp = sum(prcp, na.rm = TRUE),
            snow = sum(snow, na.rm = TRUE),
            snwd = max(snwd, na.rm = TRUE)) %>%
  st_as_sf()
```


```{r}
time_pd_merger <- function(site){
  
  bounds <- daily_well_timeline %>%
    dplyr::filter(well == site)
  
  well_loc <- POD_park %>%
    dplyr::filter(well == site)
  
  precip_data <- noaa_data %>%
    filter(!is.na(prcp)) %>%
    group_by(name) %>%
    filter(date >= bounds$min & date <= bounds$max) %>%
    summarize(actual_n = n()) %>%
    # must be at least an 80% overlap between USGS and NOAA datasets:
    filter(actual_n >= (bounds$possible_n * 0.8))
  
  # Find the nearest NOAA station that meets the minimum data requirements:
  well_loc$nearest_station <- st_nearest_feature(well_loc, precip_data)
  
  # Grab the actual distance between the nearest NOAA station and the USGS gage
  well_loc <- well_loc %>%
    mutate(distance_to_station = sf::st_distance(well_loc, precip_data[well_loc$nearest_station,], by_element = TRUE),
           nearest_station = precip_data[well_loc$nearest_station,]$name) %>%
    select(well, nearest_station, distance_to_station)
  
  return(well_loc)
  
}

nearest_noaa <- unique(well_daily$well) %>%
  map_dfr(~time_pd_merger(.)) 

wells_n_noaa <- left_join(well_daily,  nearest_noaa, by = "well") %>%
  inner_join(., noaa_data, by = c("nearest_station" = "name", "date"))

ggplot(wells_n_noaa) +
  geom_point(aes(x = prcp, y = static_mm, color = season)) +
  facet_wrap(~well, nrow=2)



ggplotly(
  ggplot() +
    geom_line(data = new, aes(x = date, y = prcp), color = "#002FA7") +
    geom_line(data = new, aes(x = date, y = static_mm/1000), color = "red") +
    facet_wrap(~well, nrow = 2) +
    theme_bw()
)
```

```{r}
ym_wells_n_noaa <- left_join(well_monthly, nearest_noaa, by = "well") %>%
  inner_join(., noaa_data_ym, by = c("nearest_station" = "name", "ym")) %>%
  # I think this is the safest thing to do...
  mutate(prcp_filled = ifelse(is.na(prcp), 0, prcp)) %>%
  group_by(well) %>%
  mutate(prcp_4rollavg = RcppRoll::roll_mean(prcp_filled, n = 4, align = 'right', na.rm = F, fill = NA_real_),
         prcp_3rollavg = RcppRoll::roll_mean(prcp_filled, n = 3, align = 'right', na.rm = F, fill = NA_real_),
         prcp_2rollavg = RcppRoll::roll_mean(prcp_filled, n = 2, align = 'right', na.rm = F, fill = NA_real_))

ggplot(ym_wells_n_noaa) +
  geom_point(aes(x = prcp, y = mean_static_mm, color = season)) +
  facet_wrap(~well, nrow=2)

ggplotly(
  ggplot() +
    geom_line(data = ym_wells_n_noaa, aes(x = ym, y = prcp), color = "#002FA7") +
    geom_line(data = ym_wells_n_noaa, aes(x = ym, y = mean_static_mm), color = "red") +
    facet_wrap(~well, nrow = 2) +
    theme_bw()
)
```

```{r}

corr_finder <- function(site){
  
  sub <- ym_wells_n_noaa %>%
    ungroup() %>%
    filter(well == site) %>%
    select(well, ym, prcp, mean_static_mm) %>%
    mutate_all(~ifelse(is.nan(.), NA, .)) %>%
    mutate(mean_static_mm_filled = zoo::na.approx(mean_static_mm),
           prcp_filled = ifelse(is.na(prcp), 0, prcp))
  
  precip <- ts(sub$prcp_filled, start = 1)
  flow <- ts(sub$mean_static_mm_filled, start = 1)
  
  cross_correlation <- ccf(precip, flow)
  
  # Plot the cross-correlation function
  plot(cross_correlation, main = "Cross-Correlation Function", xlab = "Lag", ylab = "Correlation")
  
}
```