---
title: "BRCA Data Exploration"
author: "Caitlin Mothes and Katie Willi"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: paper
    code_folding: show
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      error = FALSE,
                      message = FALSE)

source("setup.R")

#load("supp/all_objects.RData")
```

This workflow explores correlations between NPS's water balance model (NPS WBM), climate variables, stream flow, and groundwater levels in and around Bryce Canyon National Park (BRCA).

## Downloading data

##### Park watersheds

```{r, eval = FALSE, message = FALSE, warning = FALSE}
# get park boundary
park_boundary <- getParkBoundary(park = "BRCA")

# pull in the park watersheds as a starting AOI for pulling in WBM data:
park_watershed <- getWatersheds(aoi = park_boundary, save = FALSE)

# get NHD HR flowlines within the boundary
park_flowlines <- mapNHDPlusHR(aoi = summarize(park_watershed)) %>% 
  summarize()
```

##### Water supply watersheds

NPS water supply locations may not necessarily be within the park, and therefore their watersheds may not be represented in the park boundary's watersheds delineated above. So, here I am pulling in the water supply locations of interest, and delineating their own watersheds to ensure we capture them for pulling in more data. Water supply locations are found using the [Utah Division of Water Rights database](https://maps.waterrights.utah.gov/asp/wrplatGE.asp).

```{r, eval = FALSE, message = FALSE, warning = FALSE}
# get Utah points of diversion near BRCA
POD_Utah <- getPODUtah(aoi = park_watershed, dist = 0.1)

# filter to water supplies of interest
POD_park <- POD_Utah %>%
  dplyr::filter(WRNUM %in% c("61-893", "2061001M00")) %>% #, # current supply
  #"61-1143")) %>% # potential future supply
  distinct(LOCATION, .keep_all = TRUE) 

watersupply_watershed <- vector("list", nrow(POD_park))

# get the watersheds of different points:
for(i in 1:nrow(POD_park)){
  
  watersupply_watershed[[i]] <- POD_park[i,] %>% 
    getXYWatersheds(sf = ., coordinates = NULL)
  
}

watersupply_watershed <- watersupply_watershed %>%
  bind_rows() %>% 
  distinct(featureid, .keep_all = TRUE) %>%
  #... hard to tell from topo what the future supply's real watershed looks like... 
  # But! This future supply is a deep (100 ft) well, so it may not be as important.
  # I'll need to look into this further at some point.
  filter(!featureid %in% c("10807991", "10807997"))

watersupply_flowlines <- mapNHDPlusHR(aoi = summarize(watersupply_watershed))
```

##### USGS stream gage watersheds

For many parks, the nearest USGS stream gage is far away. Therefore, we are pulling all NWIS gages within 100 km of the park boundary. Of those, we only select stream gages that are considered "reference" gages in the [GAGES-II database (Falcone, 2011)](https://pubs.usgs.gov/publication/70046617). Then, we delineate each of those gages' watersheds using the `get_nldi_basin()` function from the {nhdplusTools} package:

```{r, eval = FALSE, message = FALSE, warning = FALSE}
# area around the park ~ 100 km away:
aoi <- sf::st_buffer(park_boundary, dist = 0.3)
# locate NWIS daily flow locations in that radius:
nwis <- listNWIS(aoi = aoi, dist = 0) %>%
  # daily values...
  filter(data_type_cd == "dv",
         # ... of flow
         code == "00060") %>%
  # for comparison purposes, need data from 1980 onwards
  filter(year(end_date) >= 1980)

nwis_groundwater <- listNWIS(aoi = aoi, dist = 0) %>%
  # locations with more than one days' worth of data:
  filter(begin_date != end_date,
         year(end_date) >= 2020,
         n_obs > 10,
         # groundwater sites only:
         site_type_cd == "GW",
         data_type_cd == "gw")
# pull those sites' flow data
getNWIS(inventory = nwis_groundwater, park = "misc", path = "data/")
gw_data <- list.files('data/misc/nwis/gw', full.names = TRUE) %>%
  map_dfr(~read_csv(.))

# find the NWIS gages that are (crudely, probably) representative of natural conditions:
ref_gages <- get_gagesII(id = nwis$site_no) %>%
  filter(class == "Ref")

nwis <- nwis %>%
  filter(site_no %in% ref_gages$staid) %>%
  left_join(st_drop_geometry(ref_gages), by = c("site_no" ="staid"))

# for(i in 1:nrow(nwis)){
#   nwis$comid[i] <- discover_nhdplus_id(nwis[i,])
# }

# pull those sites' flow data
getNWIS(inventory = nwis, park = "misc", path = "data/")

# where are they?
# mapview(nwis) + mapview(park_boundary)

nldi_finder <- function(site_no){
  # Now, get those gages' watersheds using get_nldi_basin in the {nhdplusTools}.
  # Input for NLDI requires "USGS-" before the gage number
  nldi_nwis <- list(featureSource = "nwissite",
                    featureID = paste0("USGS-", site_no))
  
  invisible(suppressMessages(gage_basin <- nhdplusTools::get_nldi_basin(nldi_feature = nldi_nwis) %>%
                               st_transform(., 4269) %>%
                               mutate(site_no = site_no)))
  
  return(gage_basin)
  
}

nldi_meta <- function(site_no){
  # Now, get those gages' watersheds using get_nldi_basin in the {nhdplusTools}.
  # Input for NLDI requires "USGS-" before the gage number
  nldi_nwis <- list(featureSource = "nwissite",
                    featureID = paste0("USGS-", site_no))
  
  gage_basin <- nhdplusTools::get_nldi_characteristics(nldi_feature = nldi_nwis, type = "total")[[1]] %>%
    filter(characteristic_id %in% c("TOT_ELEV_MEAN", "TOT_ELEV_MAX", "TOT_ELEV_MIN")) %>%
    pivot_wider(-percent_nodata, values_from = characteristic_value, names_from = characteristic_id)
  
  return(gage_basin)
  
}

nldi_watershed <- nwis$site_no %>%
  map_dfr(~nldi_finder(site_no = .)) %>%
  mutate(data = map(site_no, ~nldi_meta(site_no = .))) %>%
  unnest() %>%
  left_join(st_drop_geometry(nwis), by = "site_no")

nldi_flowlines <- mapNHDPlusHR(aoi = summarize(nldi_watershed)) %>% 
  summarize()
```

```{r, echo = FALSE, error = FALSE, message = FALSE, warning = FALSE}
mapview(park_boundary, 
        col.regions = "#74a089", 
        alpha.regions = 0, 
        lwd = 2, 
        popup = FALSE, 
        legend = F, 
        homebutton = FALSE,
        label = FALSE) + 
  mapview(park_watershed,
          col.regions="#56B4E9", 
          alpha.regions = 0.33, 
          lwd = 0, 
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE) +
  mapview(watersupply_watershed,
          col.regions="#002fa7", 
          alpha.regions = 0.33, 
          lwd = 0, 
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE) +
  mapview(park_flowlines,
          col.regions = "darkblue",
          lwd = 0.5,
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE) +
  mapview(filter(watersupply_flowlines, !NHDPlusID %in% c(70000200004597,70000200033909)),
          col.regions = "darkblue",
          lwd = 0.5,
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE) +
  mapview(nldi_flowlines,
          col.regions = "darkblue",
          lwd = 0.5,
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE) +
  mapview(POD_park,
          col.regions = c("#E69F00"), # orange
          alpha.regions = 1,
          alpha = 1,
          cex = 6, 
          layer.name = "Park Water Supply") +
  mapview(nldi_watershed,
          col.regions="#002fa7", 
          alpha.regions = 0.33, 
          lwd = 0, 
          popup = FALSE, 
          legend = FALSE, 
          homebutton = FALSE,
          label = FALSE)  +
  mapview(nwis,        
          col.regions = c("maroon"), # orange
          alpha.regions = 1,
          alpha = 1,
          cex = 6, 
          layer.name = "USGS Stream Gage")
```

Lastly, we dissolve all of these watersheds into a single shapefile that we can use to download all future data.

```{r, eval = FALSE, message = FALSE, warning = FALSE}
# our AOI blob!
final_aoi <- park_watershed %>%
  bind_rows(watersupply_watershed) %>%
  bind_rows(nldi_watershed) %>%
  summarize()
```

### Pulling in explanatory variables to explain water supply levels

**KW REMINDER** Running list of things I'd like to explore:

-   GridMet (temp, precip, P-PET?, other wbm vars)... with a lag?
-   DayMet (temp, precip, P-PET?, other wbm vars)... with a lag?
-   StreamCat variables?
-   Visitation and/or water use?
-   Nearby weather station data
-   Nearby stream data

Here I pull in NPS's gridded monthly water balance predictions (4km resolution). This data comes from [Which Water Balance Model Do You Need? -\> Historical THREDDS](https://screenedcleanedsummaries.s3.us-west-2.amazonaws.com/which_water_balance.html). The function below downloads and crops these gridded monthly water balance predictions (from 1980-2022) for our area of interest. This includes the WBM variables soil water content, runoff, rain, accumulated snow water equivalent, PET, deficit, and AET. It then converts the information into a table. The coordinates of the grid centroids are preserved. For all variables across all years, this takes a little over an hour (for daily GridMET).We can also download and explore additional gridded climate characteristics from GridMET, including temperature, precipitation, relative humidity, PET, wind speed, and vapor pressure deficit.

```{r, eval = FALSE}
options(timeout = 900)
getHistoricWBMGridMET(time = "daily", park = "misc", aoi = summarize(watersupply_watershed), path = "data/", wb_vars = c("soil_water", "runoff", "rain", "accumswe", "PET", "Deficit", "AET"))

# getHistoricWBMDayMET(park = "misc", aoi = final_aoi, path = "data/", wb_vars = c("soil_water", "runoff", "rain", "agdd", "accumswe", "PET", "Deficit", "AET"))

# all gridMET, full park AOI:
gridmet_vars <- get_gridMET(time = "daily",
                            path = "data/", 
                            park = "misc", 
                            aoi = final_aoi, 
                            vars = c("tmmx", "tmmn", "pr", "rmax", "rmin", 
                                     "pet", "etr", "vpd", "vs"), 
                            start = "1979-01-01", 
                            end = "2022-12-31")
# function to grab gridMET vars at either a single point, or across
# an area of interest
raster_puller <- function(filename, point, aoi){
  
  data <-  data.table::fread(filename) 
  
  try(data <- data %>%
        mutate(x = lon,
               y = lat))
  
  if(is.null(aoi)){
    
    tab_data <- data %>%   
       st_as_sf(coords = c("x","y"), crs = st_crs(point)) %>%
       as_tibble()
     
     ID_raster <- data %>%
       group_by(x, y) %>%
       summarize() %>%
       rowid_to_column() %>%
       st_as_sf(coords = c("x","y"), crs = st_crs(point))
     
     final <- point %>%
       mutate(rowid = sf::st_nearest_feature(., ID_raster)) %>%
       inner_join(., as_tibble(ID_raster) , by = "rowid") %>%
       inner_join(tab_data, by = c("geometry.y" = "geometry"))
     
     }
  
  if(is.null(point)){
    
    final <-  data %>%
      st_as_sf(coords = c("x","y"), crs = st_crs(aoi)) %>%
      .[aoi,]
    }
  
  return(final)
  
  }

# gridMET data for the well location:
gridmet_data <- list.files('data/misc/gridmet_hist_daily/', full.names = TRUE) %>%
  map(~raster_puller(filename = ., aoi = NULL, point = POD_park[1,])) %>%
  bind_rows() %>%
  data.table::data.table() %>%
  select(date = ym, variable, value) %>%
  distinct(.keep_all = TRUE) %>%
  pivot_wider(names_from = "variable", values_from = "value") %>%
  mutate(date = ymd(date))
colnames(gridmet_data) <- paste0(colnames(gridmet_data), ".gridmet")

# gridMET data for the watershed of the well:
gridmet_ws <- list.files('data/misc/gridmet_hist_daily/', full.names = TRUE) %>%
  map(~raster_puller(filename = ., point = NULL, aoi = summarize(watersupply_watershed))) %>%
  bind_rows() %>%
  data.table::data.table() %>%
  dplyr::select(date = ym, variable, value, geometry) %>%
  distinct(.keep_all = TRUE) %>%
  pivot_wider(names_from = "variable", values_from = "value") %>%
  select(-geometry) %>%
  mutate(date = ymd(date)) %>%
  group_by(date) %>%
  summarize_all(mean, na.rm = TRUE) 
colnames(gridmet_ws) <- paste0(colnames(gridmet_ws), ".gridmet.ws")

# Water Balance variables (based on GridMET) at the well location:
gridmet_wbm <- list.files('data/misc/wbm_gridmet_hist_daily/temp/', full.names = TRUE) %>%
  map(~raster_puller(filename = ., point = POD_park[1], aoi = NULL)) %>%
  bind_rows() %>%
  data.table::data.table() %>%
  select(date, val, var) %>%
  st_drop_geometry() %>%
  distinct(.keep_all = TRUE) %>%
  pivot_wider(names_from = "var", values_from = "val")
colnames(gridmet_wbm) <- paste0(colnames(gridmet_wbm), ".wbm")

# Water Balance variables across the well watershed:
gridmet_wbm_ws <- list.files('data/misc/wbm_gridmet_hist_daily/', full.names = TRUE) %>%
  map(~raster_puller(filename = ., point = NULL, aoi = summarize(watersupply_watershed))) %>%
  bind_rows() %>%
  data.table::data.table() %>%
  mutate(date = ymd(substr(time, 1, 10))) %>%
  select(date, val, var, geometry) %>%
  st_drop_geometry() %>%
  distinct(.keep_all = TRUE) %>%
  pivot_wider(names_from = "var", values_from = "val") %>%
  group_by(date) %>%
  summarize_all(mean, na.rm = TRUE)
colnames(gridmet_wbm_ws) <- paste0(colnames(gridmet_wbm_ws), ".wbm.ws")
```

We can also locate the nearest weather stations with the most appropriate data record:

```{r, eval = FALSE}
# Find NOAA weather stations near our areas of interest
noaa_data <- getNOAA(aoi = st_buffer(final_aoi, 0.1), park = "misc") %>%
    # prcp = Precipitation (tenths of mm)
    # snow = Snowfall (mm)
    # snwd = Snow depth (mm)
    # tmax = Maximum temperature (tenths of degrees C)
    # tmin = Minimum temperature (tenths of degrees C)
    # elevation = meters
    select(name, id, date, tmax, tmin, prcp, snow, snwd, elevation, geometry) %>%
    # Raw NOAA data is in "tenths of" units for temp and precip:
    mutate_at(c("tmax", "tmin", "prcp"), function(x) {x * 0.10})

noaa_data_sub <- noaa_data %>%
  data.table::data.table() %>%
  mutate(ym = ym(substr(date, 1, 7))) %>%
  # get parks with data during our well dataframe
  filter(year(ym) >= 2000 & year(ym) <= 2022) %>%
  st_as_sf() %>%
  filter(name == "BRYCE CANYON NP HQRS")

tab_data <- noaa_data_sub %>%
  as_tibble()

ID_noaa <- noaa_data_sub %>%
  group_by(name, id) %>%
  summarize() %>%
  rowid_to_column() 

# Find the nearest NOAA station to the wells:
nearby_noaa <- ID_noaa %>%
  filter(rowid == st_nearest_feature(POD_park, ID_noaa)[1]) %>%
  st_drop_geometry() %>%
  inner_join(., tab_data, by = "name") %>% 
  dplyr::select(name, date, ym, tmax, tmin, prcp, snow, snwd)
colnames(nearby_noaa) <- paste0(colnames(nearby_noaa), ".noaa")
```

## East Creek well data

BRCA has been measuring static water levels at their East Creek water supply wells since at least 2000. These wells are the current source for the park's public water supply. Well 1 is 90 feet deep with a suspected perforated casing from 50-60 feet below ground surface, and is the furthest well "upstream". Well 2 is 522 feet deep with a suspected 10-foot casing at the bottom of the well, and is about 400 feet directly down the valley from Well 1. Meanwhile, there is a third well that is likely similary constructed as Well 2 and located next to Well 2. Well 3 has no pump and has likely never been in use.

A report written in 1998 about the wellfield described the system as being an alluvial aquifer recharged by infiltration of rainflow and streamflow into the East Creek drainage basin. Discharge of bedrock springs, such as Whiteman Spring, provide an additional source of recharge. The report also purported that the aquifer stores approximately 2.6 million cubic feet of water. A pump test performed in 1997 was also described, and culminated in the following results:

\- Hydraulic conductivity ratio - 1:10 (ratio of vertical to horizontal hydraulic conductivity)

\- Transmissivity (T) = 8900 ft\^2/day

\- Specific Yield (Sy) = 0.37

\- Kr = 150 feet/day

\- Aquifer thickness = 60 feet

\- Hydraulic gradient between well 1 and 2 = 0.0057 ft/ft

\- Hydraulic gradient upstream of well field = 0.0042 ft/ft

\- Average daily use = 112,000 gallons/day (or, 15,000 cubic feet/day) … during summer pumpage… so greatly overestimates winter use.

```{r, eval = FALSE, message = FALSE, warning = FALSE}
well_data <- read_csv('data/park/BRCA/manual/BRCA_Well_Data.csv') 
well_data_other <- read_csv('data/park/BRCA/manual/BRCA_Well_Data_Digitized.csv')
names(well_data) <- make.names(names(well_data))
well_daily <- well_data %>%
  dplyr::mutate(static_in = as.numeric(str_replace(Static..in., "-", "")),
                date = mdy(Date),
                ym = ym(substr(date, 1, 7))) %>%
  dplyr::select(date,
                ym,
                well = Well,
                static_in)

# The state of Utah also tracks monthly water use of that system:

water_supply <- getWaterSuppliersUtah(aoi = park_boundary) %>%
    filter(grepl("National Park", WRNAME, ignore.case=TRUE)) %>%
    .$WRID

water_use_1 <- getWaterUseUtah(WRID = water_supply)[[1]] %>%
  slice(1:39) %>%
  pivot_longer(-c("Year", "Method of Measurement"), names_to = "month", values_to = "use_acre_feet") %>%
  mutate(ym = ym(paste0(Year, "-", month))) %>%
  filter(month != "Annual inAcre Feet") %>%
  select(ym, use_acre_feet) %>%
  mutate(well = "Well 1")

water_use_2 <- getWaterUseUtah(WRID = water_supply)[[1]] %>%
  slice(51:nrow(.)) %>%
  dplyr::filter(!is.na(as.numeric(Year))) %>%
  pivot_longer(-c("Year", "Method of Measurement"), names_to = "month", values_to = "use_acre_feet") %>%
  mutate(ym = ym(paste0(Year, "-", month))) %>%
  filter(month != "Annual inAcre Feet") %>%
  select(ym, use_acre_feet) %>%
  mutate(well = "Well 2")

both_wells <- water_use_1 %>%
  bind_rows(water_use_2)

# Here we combine the average monthly static water levels with the monthly water use:

well_munge <- well_daily %>%
  left_join(both_wells, by = c("ym", "well"))

all_nwis_flow <- list.files("data/misc/nwis/dv/", full.names = TRUE) %>%
  map_dfr(~ read_csv(.) %>% 
            data.table::data.table() %>% 
            mutate(across(everything(), as.character))) %>%
  bind_rows() %>%
  mutate(dateTime = lubridate::ymd(dateTime),
         ym = ym(substr(dateTime, 1, 7)),
         flow_cfs = as.numeric(X_00060_00003)) %>%
  left_join(st_drop_geometry(nldi_watershed), by = "site_no") %>%
  mutate(flow_mmd = (flow_cfs * 28.3168) / (drain_sqkm * 1e6 * 1e6)) %>%
  pivot_wider(names_from = "site_no", values_from = "flow_mmd") %>%
  select(2, mammoth_ck = 35, usgs2 = 36)

# NPS tracks monthly total park visitors. Here we pull that information in for the park:
visitors <- getUnitVisitation(units = "BRCA", startYear = 2000, endYear = 2023) %>%
  mutate(ym = ym(paste0(Year, "-", Month))) %>%
  select(ym, RecreationVisitors)

# bind all the data together:
all_brca_data <- well_munge %>%
  left_join(visitors, by = ("ym")) %>%
  left_join(., gridmet_data, by = c("date" = "date.gridmet")) %>%
  dplyr::select(well, date, ym, 
                mean_static = static_in, 
                rec_visitation = RecreationVisitors, 
                use_acre_feet, 
                etr.gridmet, pet.gridmet, pr.gridmet, rmax.gridmet, rmin.gridmet, tmmn.gridmet, tmmx.gridmet, vpd.gridmet, vs.gridmet) %>%
  distinct(.keep_all = TRUE) %>%
  left_join(gridmet_ws, by = c("date" = "date.gridmet.ws")) %>%
  left_join(all_nwis_flow, by = c("date"="dateTime")) %>%
  left_join(gridmet_wbm, by = c("date" = "date.wbm")) %>%
  left_join(gridmet_wbm_ws, by = c("date" = "date.wbm.ws")) %>%
  left_join(nearby_noaa, by = c("date"="date.noaa")) %>%
  # new variables:
  mutate(mean_static = 18288 - (25.4 * (mean_static)),
         tmean.gridmet = (tmmn.gridmet + tmmx.gridmet)/2,
         p.pet.gridmet = pr.gridmet - pet.gridmet,
         p.pet.wbm = pr.gridmet - PET.wbm,
         p.t.gridmet = pr.gridmet * tmean.gridmet,
         runoff.soilwater.snow.wbm = runoff.wbm + soil_water.wbm + accumswe.wbm,
         season = case_when(month(ym) %in% c(12,1,2) ~ "Winter",
                            month(ym) %in% c(3,4,5) ~ "Spring",
                            month(ym) %in% c(6,7,8) ~ "Summer",
                            month(ym) %in% c(9,10,11) ~ "Fall")) %>%
  dplyr::select(-c(names(.)[grepl("ym.", names(.))])) 
```

## Figures

Here I'm exploring the data. Reminder, all climate variables are taken from the 4-km grid that the water supply coordinates are contained within; as well as means across the water supply's drainage basin (i.e., East Creek's watershed, denoted with ".ws" tacked onto the variable name).

Monthly well data at BRCA:

Static level is the depth to the water table from the ground surface when the pump is not running. Meaning, the bigger the value, the lower the water levels in the well casing (and less water). This is a proxy for the natural water levels of the aquifer.

```{r, fig.height = 11, fig.width = 9, echo = FALSE, error = FALSE, message = FALSE, warning = FALSE}
well_data <- ggplot(data = all_brca_data) +
  geom_line(aes(x = date, y = mean_static, color = well)) +
  # geom_col(aes( x = ym, y = pr))
  #facet_wrap(~well, nrow = 2) +
  theme_bw() +
  xlab("") +
  ylab("Well Level (mm)") +
  scale_color_manual(values = c("#242546", "#DF2057")) +  # Set line colors
  theme(legend.position = "none")  # Move legend to the bottom

streamflow <- ggplot(data = filter(all_brca_data, well == "Well 1")) +
  geom_col(aes(x = date, y = mammoth_ck), color = "#242546") +
  theme_bw() +
  xlab("") +
  ylab("Mammoth Ck. (mmd)")

precip <- ggplot(data = filter(all_brca_data, well == "Well 1")) +
  geom_col(aes( x = date, y = pr.gridmet), color = "#242546") +
  theme_bw() +
  xlab("") +
  ylab("Precip. (mm)")

swe <- ggplot(data = filter(all_brca_data, well == "Well 1")) +
  geom_col(aes(x = date, y = accumswe.wbm), color = "#242546") +
  theme_bw() +
  xlab("") +
  ylab("SWE (mm)")

use <- ggplot() +
  geom_line(data = all_brca_data,
            aes(x = ym, y = as.numeric(use_acre_feet), color = well)) +
  theme_bw() +
  scale_color_manual(values = c("#242546", "#DF2057")) +  # Set line colors
  xlab("") +
  ylab("Use (acre-ft)") +
  theme(legend.position = "none") 

visitors <- ggplot() +
  geom_line(data = filter(all_brca_data, !is.na(rec_visitation) & well == "Well 1"), 
            aes(x = ym, y = as.numeric(rec_visitation)),
            color = "#242546") +
  theme_bw() +
  xlab("Date") +
  ylab("Visitors")

ggarrange(well_data, use, streamflow, precip, swe, visitors, nrow = 6, align = "v")
```

## Cross-correlation

Interpretation: a positive lag indicates that the well levels shift in response to the other variable. One lag unit = one day. A negative correlation indicates GW flows decrease with increasing variable magnitude. Positive correlation indicates GW flows increase with. increasing variable magnitude. Some of these make sense... others do not... none are that significant on their own. 

```{r, echo = FALSE, error = FALSE, message = FALSE, warning = FALSE}
site <- unique(all_brca_data$well)

sub_brca_data<- filter(all_brca_data, well == site[1])

ccf_munger <- function(column){
  
  ts_vector <- sub_brca_data %>%
    select(column) %>%
    pull()
  #zoo::na.approx
  ts <- (ts(as.numeric(ts_vector), start = 1))
  
  well.depth <- (ts(sub_brca_data$mean_static, start = 1))
  
  result <- ccf(ts, well.depth, na.action = na.pass, type = "correlation", plot = FALSE, lag.max = 365)
  
  plot(result, main = paste0("Correlation of well data with ", column), xlab = "Lag", ylab = paste0("Correlation"))
  
  ccf_df <- tibble(lag_days = c(result$lag), 
                   correlation = c(result$acf)) %>%
    mutate(variable = column)
  
  return(ccf_df)
  
}

ccfs <- names(sub_brca_data)[c(5:25, 27:40, 42:43, 47:51)] %>%
  map(~ ccf_munger(column = .)) %>%
  bind_rows() 

ccf <- ccfs %>%
  group_by(variable) %>%
  # Vars impact well, never the other way around
  filter((lag_days) >= 0) %>%
  # what are the highest-correlated lags?
  filter(abs(correlation) == max(abs(correlation), na.rm = TRUE)) 

ccf %>%
  DT::datatable(filter = "none",
                caption = 'Results of cross-correlation of misc. variables with well level. Listed per variable is the highest-correlated lag time.',
                rownames = FALSE,
                fillContainer = T,
                escape = FALSE,
                options = list(dom = 't',
                               pageLength = nrow(.),
                               scrollY = '300px'))
```

## Water Use and Visitor Use -- Is there a real relationship?

```{r, echo = FALSE, error = FALSE, message = FALSE, warning = FALSE}
vis <- all_brca_data %>%
  distinct(ym, well, .keep_all = TRUE) %>%
  group_by(ym, season) %>%
  summarize(use_acre_feet = sum(as.numeric(use_acre_feet), na.rm = TRUE),
            rec_visitation = mean(rec_visitation, na.rm = TRUE))

vis <- all_brca_data %>%
  filter(well == "Well 1") %>%
  group_by(ym, season) %>%
  summarize(mean_static = mean(mean_static, na.rm = TRUE)) %>%
  left_join(vis, by = c("season", "ym")) %>%
  mutate(wyear = ifelse(month(ym) >= 10, year(ym) + 1, year(ym))) %>%
  filter(wyear >= 2010)

ggplotly(ggplot(data = vis) + # %>% filter(wyear > 2010)) +
           geom_point(aes(x = rec_visitation, y = use_acre_feet, color = season)) +
           xlab("BRCA Visitation") +
           ylab("Water Use (acre-feet)") +
           theme_bw() +
           scale_color_manual(values = c("#df2057", "#002fa7","#85f4fe", "#d6f8a0")) +
           # Add linear trend line and R-squared
           geom_smooth(aes(x = rec_visitation, y = use_acre_feet), color = "black", method = "lm", se = FALSE) +
           # Add R-squared to plot
           annotate("text", 
                    x = max(vis$rec_visitation) - 200000, 
                    y = min(vis$use_acre_feet) + 1,
                    label = paste("R² =", round(summary(lm(use_acre_feet ~ rec_visitation, data = vis))$r.squared, 2)),
                    size = 5) +
           ggtitle("2010-2022"))

old_vis <- all_brca_data %>%
  distinct(ym, well, .keep_all = TRUE) %>%
  group_by(ym, season) %>%
  summarize(use_acre_feet = sum(as.numeric(use_acre_feet), na.rm = TRUE),
            rec_visitation = mean(rec_visitation, na.rm = TRUE))

old_vis <- all_brca_data %>%
  filter(well == "Well 1") %>%
  group_by(ym, season) %>%
  summarize(mean_static = mean(mean_static, na.rm = TRUE)) %>%
  left_join(old_vis, by = c("season", "ym")) %>%
  mutate(wyear = ifelse(month(ym) >= 10, year(ym) + 1, year(ym))) %>%
  filter(wyear < 2010)

ggplotly(ggplot(data = old_vis) + # %>% filter(wyear > 2010)) +
           geom_point(aes(x = rec_visitation, y = use_acre_feet, color = season)) +
           xlab("BRCA Visitation") +
           ylab("Water Use (acre-feet)") +
           theme_bw() +
           scale_color_manual(values = c("#df2057", "#002fa7","#85f4fe", "#d6f8a0")) +
           # Add linear trend line and R-squared
           geom_smooth(aes(x = rec_visitation, y = use_acre_feet), color = "black", method = "lm", se = FALSE) +
           # Add R-squared to plot
           annotate("text", 
                    x = max(old_vis$rec_visitation) - 100000, 
                    y = min(old_vis$use_acre_feet) + 1,
                    label = paste("R² =", round(summary(lm(use_acre_feet ~ rec_visitation, data = old_vis))$r.squared, 2)),
                    size = 5) +
           ggtitle("2000-2010"))

```

```{r, echo = TRUE}
visitors <- (ts(vis$rec_visitation, start = 1))

water_use <- (ts(vis$use_acre_feet, start = 1))

mean_static <- (ts(vis$mean_static, start = 1))

result <- ccf(visitors, mean_static,  na.action = na.pass, type = "correlation", plot = FALSE)

plot(result, main = paste0("Correlation of well level and visitation"), xlab = "Lag", ylab = paste0("Correlation"))

result <- ccf(water_use, mean_static, na.action = na.pass, type = "correlation", plot = FALSE)

plot(result, main = paste0("Correlation of well level and water use"), xlab = "Lag (months)", ylab = paste0("Correlation"))
```

## How does the WBM data look at the park centroids vs. the water supply?

```{r, eval = FALSE, echo = FALSE}
reader <- function(file){
  
data.table::fread(file) %>%
    mutate(type = file)

}

centroids <- list.files('data/misc/centroids/', full.names = TRUE, pattern = "*.csv") %>%
  map(~reader(.)) %>%
  bind_rows() %>%
  dplyr::select("date.wbm" = "Date",
         "Deficit.wbm" = "Deficit in",
         "AET.wbm" = "AET in",
         "soil_water.wbm" = "soil_water in",
         "runoff.wbm" = "runoff in", 
         "rain.wbm" = "rain in",
         "accumswe.wbm" = "accumswe in",
         "PET.wbm" = "PET in",
         "type") %>%
  mutate(date.wbm = ymd(date.wbm)) %>%
  bind_rows(gridmet_wbm %>% mutate(runoff.wbm = runoff.wbm/25.4))

ggplot(data = centroids)+
  geom_line(aes(x = date.wbm, y = runoff.wbm, color = type)) +
  theme(legend.position = "none")  # Move legend to the bottom

centroid_locs <- st_read('data/CCRP_automated_climate_futures/spatial-data/Koppen_sites.shp') %>%
  filter(UNIT_CODE == "BRCA") %>%
  st_drop_geometry() %>%
  st_as_sf(coords = c("Lon", "Lat"), crs = 4326) 
```

```{r, echo = FALSE}
mapview(park_boundary, 
        col.regions = "#74a089", 
        alpha.regions = .25 , 
        lwd = 1, 
        popup = FALSE, 
        legend = F, 
        homebutton = FALSE,
        label = FALSE) + 
  mapview(centroid_locs, col.region = "#df2057", 
          layer.name = "Koppen Centroids") + 
  mapview(POD_park, col.region = "#002fa7",
          layer.name = "BRCA Wells")

```


```{r, eval = FALSE, echo = FALSE}
# Water Balance variables (based on GridMET) at the park Koppen centroid 1:
gridmet_centroid_1 <- list.files('data/misc/wbm_gridmet_hist_daily/', full.names = TRUE) %>%
  map(~raster_puller(filename = ., point = centroid_locs[1,], aoi = NULL)) %>%
  bind_rows() %>%
  data.table::data.table() %>%
  mutate(date = ymd(substr(time, 1, 10))) %>%
  select(date, val, var) %>%
  st_drop_geometry() %>%
  distinct(.keep_all = TRUE) %>%
  pivot_wider(names_from = "var", values_from = "val")
colnames(gridmet_centroid_1) <- paste0(colnames(gridmet_centroid_1), ".wbm")

# Water Balance variables (based on GridMET) at the park Koppen centroid 2:
gridmet_centroid_2 <- list.files('data/misc/wbm_gridmet_hist_daily/', full.names = TRUE) %>%
  map(~raster_puller(filename = ., point = centroid_locs[2,], aoi = NULL)) %>%
  bind_rows() %>%
  data.table::data.table() %>%
  mutate(date = ymd(substr(time, 1, 10))) %>%
  select(date, val, var) %>%
  st_drop_geometry() %>%
  distinct(.keep_all = TRUE) %>%
  pivot_wider(names_from = "var", values_from = "val")
colnames(gridmet_centroid_2) <- paste0(colnames(gridmet_centroid_2), ".wbm")

compare <- gridmet_wbm %>% mutate(type = "well") %>%
  bind_rows(gridmet_centroid_1 %>% mutate(type = "centroid1")) %>%
  bind_rows(gridmet_centroid_2 %>% mutate(type = "centroid2")) %>%
  mutate(runoff.in = runoff.wbm/25.4) %>%
  mutate(ym = ym(substr(date.wbm, 1, 7))) %>%
  group_by(ym, type) %>%
  summarize(runoff_monthly = mean(runoff.in,na.rm=TRUE))
```

```{r, eval = TRUE, echo = FALSE}
ggplotly(ggplot(data = compare) +
  geom_line(aes(x = ym, y = runoff_monthly, color = type)) +
  geom_point(aes(x = ym, y = runoff_monthly, color = type)) +
  facet_wrap(~type) +
  scale_color_manual(values = c("#df2057", "#002fa7","#85f4fe")) +
  theme_bw() +
  xlab("Date") +
  ylab("Runoff (inches)") +
  theme(legend.position = "none"))  # Move legend to the bottom
```

```{eval = FALSE, echo = FALSE}
plot(wbm_2022)
# wbm_2022 <- stars::read_stars("data/misc/V_1_5_2022_gridmet_historical_runoff.nc4")

save.image(file = "supp/all_objects.RData")
```

## Groundwater flow and use

We need to estimate groundwater flow. How can we do this? We have the following characteristic of the aquifer, can we use these to estimate that when we couple them with water level data?

KW: length/K? depth? 

\- Hydraulic conductivity ratio - 1:10 (ratio of vertical to horizontal hydraulic conductivity)

\- Transmissivity (T) = 8900 ft\^2/day

\- Specific Yield (Sy) = 0.37

\- Kr = 150 feet/day

\- Aquifer thickness = 60 feet

\- Hydraulic gradient between well 1 and 2 = 0.0057 ft/ft

\- Hydraulic gradient upstream of well field = 0.0042 ft/ft

\- Average daily use = 112,000 gallons/day (or, 15,000 cubic feet/day) … during summer pumpage… so greatly overestimates winter use.

Once we've gotten an estimate of groundwater flow - we can compare this to precip (Q_gw/P?). We can also compare it to use (Use/Q_gw?).

```{r}

```





2.2.1. Water balance

The daily water balance model estimates components of the water cycle from precipitation and temperature available from gridded climate data sets or weather stations using the equations outlined by Lutz’ supplemental (Lutz et al., 2010; Thornthwaite, 1948). Our only modification was adjusting the equations to reflect a daily rather than monthly time-step.
The model partitions total precipitation (P, mm) into rain (RAIN) or snow (SNOW), the latter of which accumulates until temperatures (T, o C) become warm enough to melt (BASED ON JENNINGS CURRENTLY). Soil moisture (SM, mm) is the quantity of water stored in the top meter of soil. Soil was treated as a single layer that has a maximum storage defined by its water holding capacity obtained from soil surveys available for the non-wilderness portion of the park (Web Soil Survey available at http://websoilsurvey.nrcs.
usda.gov, Accessed 24 May 2015). Water inputs into the soil that exceed storage capacity become runoff. Potential evapotranspiration (PET, mm), calculated via the Hamon method is the amount of water that could be evaporated and transpired from a short grass with available energy if water is unlimited. Actual evapotranspiration (AET, mm) is the loss of
water from soil via evaporation and transpiration. AET is limited by soil moisture. Climatic water deficit (CWD, mm) is the amount of additional water vegetation would use if available, calculated as the difference between PET and AET (Stephenson, 1998). The components of the water balance that indicate water availability include P, RAIN, SNOW, and SM.
Those that estimate water use include AET and PET, while CWD is an estimate of unmet water need. Two aspects of heat
that influence vegetation growth include average annual temperature TAVG, and growing degree days (GDD) (Mcmaster
et al., 1997).


For the stream flow analysis, we used climate data from a weather station (Medano Pass SNOTEL, https://wcc.sc.egov.usda.
gov/nwcc/site?sitenum¼914) that matched the period of record for stream flow measurements (1997e2019). There were no
missing precipitation data, but 0.21 percent of temperature data were missing (Supplemental Table A.2). For the vegetation
and wildfire analyses we ran the models at the center of vegetation map units and wildfire perimeters using 1 km Daymet
daily temperature and precipitation time series (Thornton et al., 2018). The vegetation and fire analyses used Daymet data for
the periods 1997-2015 and 1980-2015, respectively. The water balance model accounted for heat load variation due to slope
and aspect determined from the spatial average of 30 m resolution digital elevation model, thus modifying the local climate in
complex mountain topography. Our water balance model is one-dimensional in the vertical domain of a soil profile without
contribution from upslope positions or from ground water addition. Temporal resolution of model output was daily for
wildfire and stream flow analyses but aggregated to annual periodicity for vegetation analysis. We determined autocorre-
lation in climate and water balance time series was insignificant (<4 percent of locations) at the annual periodicity used in
analysis of wildfire or vegetation condition. We used a holdout dataset to validate the stream flow model with a training
period from 1997 to 2015 and a validation period from 2016 to 2019.

2.2.2. Stream flow
Our stream flow modeling involved a hybrid approach relying on the water balance model to account for physical
processes of runoff generation and evapotranspiration loss to the atmosphere, and statistical methods to account for spatial variability in watershed physical characteristics that modify flow generation (Garen, 2013). Specifically, since our climate
input to the water balance model was from a single weather station, we simulated runoff input to the watershed by
replicating the model runs using a range of soil water holding capacity in 15 equally spaced increments from 1 to 500 mm.
This was to help account for variation in soil properties in a complex watershed. All 15 runs of the model were averaged by
day into a single time series to create a single daily runoff value for the watershed. This composite time series was then
smoothed with a 30-day moving average to account for flow attenuation and the varying rate at which water from
disparate locations reached the gauge. We describe the relationship between monthly runoff and monthly measured flow
with a third order polynomial (linear and quadratic regressions had poorer fit) and found that the runoff from the water
balance model had peaks and patterns that corresponded to but preceded measured flow in time. We accounted for travel
time of water through the watershed to the gauge by iteratively lagging flow in the stream relative to the modeled runoff
term from the water balance model for 1-100 days and selected the lag with the best fit (highest r 2 ). Our statistical
approach to determining lag is a simplification of processes that govern flow concentration in watersheds (USDA-NRCS,
2010) that are not included in our one-dimensional model. After identifying the appropriate lag, we determined sepa-
rate coefficients for each month from March-November (Supplemental Table A.1). Due to insufficient flow data, no predictions
were made for December-February of each year. Since our approach is a hybrid of physical process and statistical
modeling, and therefore subject to overfitting, we validated our flow model against the holdout period (2016-2019) that
was not used in model training.


```{r}

Explore relationship between groundwater levels and precip at a seasonal or yearly interval. Does peak SWE have a better relationship to level than precip alone?

```{r, error = FALSE, message = FALSE, warning = FALSE}
all_brca_data_annual <- all_brca_data %>%
  mutate(wyear = ifelse(month(ym) >= 10, year(ym) + 1, year(ym))) %>%
  group_by(wyear, season, well) %>%
  mutate(peak_swe = max(accumswe.wbm, na.rm = TRUE),
         mean_static = mean(mean_static, na.rm = TRUE),
         med_static = median(mean_static, na.rm = TRUE),
         total_precip = sum(pr.gridmet, na.rm = TRUE)) %>%
  distinct(season, wyear, .keep_all = TRUE) %>%
  ungroup() %>%
  mutate(peak_swe_thresh = ifelse(peak_swe >= stats::quantile(peak_swe, 0.95), 1, 
                                  ifelse(peak_swe <= stats::quantile(peak_swe, 0.05), 1, 0)),
         mean_static_thresh = ifelse(mean_static >= stats::quantile(mean_static, 0.95, na.rm = T), 1, 
                                     ifelse(mean_static <= stats::quantile(mean_static, 0.05, na.rm = T), 1, 0)),
         total_precip_thresh = ifelse(total_precip >= stats::quantile(total_precip, 0.95), 1, 
                                      ifelse(total_precip <= stats::quantile(total_precip, 0.05), 1, 0)))

annual_use <- all_brca_data %>%
  mutate(wyear = ifelse(month(ym) >= 10, year(ym) + 1, year(ym))) %>%
  dplyr::group_by(season, wyear) %>%
  mutate(total_use = sum(as.numeric(use_acre_feet))) %>%
  distinct(season, wyear, .keep_all = TRUE) %>%
  ungroup() %>%
  mutate(total_use_thresh = ifelse(total_use >= stats::quantile(total_use, 0.95), 1, 
                                   ifelse(total_use <= stats::quantile(total_use, 0.05), 1, 0)))

total_visitation <-  all_brca_data %>%
  filter(well == "Well 1") %>%
  mutate(wyear = ifelse(month(ym) >= 10, year(ym) + 1, year(ym))) %>%
  distinct(ym, .keep_all = TRUE) %>%
  group_by(wyear, season) %>%
  mutate(total_visitors = sum(rec_visitation)) %>%
  distinct(season, wyear, .keep_all = TRUE) %>%
  ungroup() %>%
  mutate(total_visitors_thresh = ifelse(total_visitors >= stats::quantile(total_visitors, 0.95), 1, 
                                        ifelse(total_visitors <= stats::quantile(total_visitors, 0.05), 1, 0)))

a <- ggplot(data = all_brca_data_annual) +
  geom_line(aes(x = ym, y = mean_static, color = well)) +
  geom_point(aes(x = ym, y = mean_static, color = well)) +
  geom_point(data = filter(all_brca_data_annual, mean_static_thresh == 1), aes(x = ym, y = mean_static, color = well), color = "#ff9fe5") +
  theme_bw() +
  xlab("") +
  scale_color_manual(values = c("#242546", "#DF2057")) +  # Set line colors
  ylab("Static Water Level (mm)") +
  theme(legend.position = "none") 

b <- ggplot(data = all_brca_data_annual) +
  geom_line(aes(x = ym, y = peak_swe), color = "#242546") +
  geom_point(aes(x = ym, y = peak_swe), color = "#242546") +
  geom_point(data = filter(all_brca_data_annual, peak_swe_thresh == 1), aes(x = ym, y = peak_swe, color = well), color = "#ff9fe5") +
  theme_bw() +
  xlab("") +
  ylab("Peak SWE (mm)") +
  theme(legend.position = "none") 

c <- ggplot(data = all_brca_data_annual) +
  geom_col(aes(x = ym, y = total_precip), color = "#242546") +
  geom_col(data = filter(all_brca_data_annual, total_precip_thresh == 1), aes(x = ym, y = total_precip, color = well), color = "#ff9fe5") +
  theme_bw() +
  xlab("") +
  ylab("Total Precip (mm)") +
  theme(legend.position = "none") 

d <- ggplot(data = total_visitation) +
  geom_line(aes(x = ym, y = total_visitors), color = "#242546") +
  geom_point(aes(x = ym, y = total_visitors), color = "#242546") +
  geom_point(data = filter(total_visitation, total_visitors_thresh == 1), aes(x = ym, y = total_visitors, color = well), color = "#ff9fe5") +
  theme_bw() +
  xlab("") +
  ylab("Total Visitors") +
  theme(legend.position = "none") 

e <- ggplot(data = annual_use) +
  geom_line(aes(x = ym, y = total_use), color = "#242546") +
  geom_point(aes(x = ym, y = total_use), color = "#242546") +
  geom_point(data = filter(annual_use, total_use_thresh == 1), aes(x = ym, y = total_use, color = well), color = "#ff9fe5") +
  theme_bw() +
  xlab("Water Year + Season") +
  ylab("Use (acre-feet)") +
  theme(legend.position = "none") 

(ggarrange(a, e, b, c, d, nrow = 5, align = "v"))
```


